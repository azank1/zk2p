<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2k2Peer - DEX Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Glassmorphism Effects */
        .glass-panel {
            background: rgba(26, 26, 26, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.1);
        }

        .neon-glow {
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5),
                        0 0 20px rgba(0, 255, 136, 0.3),
                        0 0 30px rgba(0, 255, 136, 0.2);
        }

        .neon-glow-blue {
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.5),
                        0 0 20px rgba(0, 170, 255, 0.3);
        }

        .neon-glow-purple {
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5),
                        0 0 20px rgba(170, 0, 255, 0.3);
        }

        /* Animations */
        @keyframes node-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes edge-draw {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes glow-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        /* Layout */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 20px;
            min-height: 100vh;
        }

        .panel {
            padding: 20px;
            overflow: hidden;
            animation: fade-in 0.5s ease;
        }

        .panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Order Entry Panel */
        .order-entry {
            grid-row: 1 / 3;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-ask {
            background: linear-gradient(135deg, #ff4444 0%, #cc3333 100%);
            color: #fff;
        }

        .btn-ask:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .btn-bid {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
        }

        .btn-bid:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .btn-clear {
            background: rgba(102, 102, 102, 0.5);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-clear:hover {
            background: rgba(136, 136, 136, 0.5);
        }

        .btn-cancel {
            background: #ff4444;
            color: white;
            border: none;
            padding: 3px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 8px;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background: #ff6666;
            transform: scale(1.05);
        }

        .btn-scenario {
            background: rgba(0, 170, 255, 0.3);
            color: white;
            border: 1px solid rgba(0, 170, 255, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 8px;
            width: 100%;
            transition: all 0.2s;
        }

        .btn-scenario:hover {
            background: rgba(0, 170, 255, 0.5);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.4);
        }

        .btn-payment {
            background: linear-gradient(135deg, #ffaa00 0%, #ff8800 100%);
            color: #000;
            font-weight: bold;
        }

        .btn-payment:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }

        .btn-payment:disabled {
            background: rgba(102, 102, 102, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        /* Payment Status Section */
        .payment-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            display: none;
        }

        .payment-section h4 {
            color: #ffaa00;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .payment-status {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
        }

        .settlement-timer {
            padding: 15px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            text-align: center;
            margin-top: 10px;
        }

        .countdown {
            font-size: 2em;
            color: #00ff88;
            font-weight: bold;
            margin: 10px 0;
        }

        .wallet-role {
            background: rgba(0, 170, 255, 0.2);
            border: 1px solid rgba(0, 170, 255, 0.4);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            color: #00aaff;
        }

        /* Toggle Switch Styling */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(102, 102, 102, 0.5);
            border-radius: 13px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            border-color: #00ff88;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 0.7em;
            color: #999;
            margin-top: 3px;
            text-transform: uppercase;
        }

        /* Order Book */
        .order-book-panel {
            grid-row: 1 / 2;
        }

        .order-book {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .order-item {
            background: rgba(26, 26, 26, 0.8);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            font-size: 0.85em;
            animation: fade-in 0.3s ease;
        }

        .order-item.ask {
            border-left-color: #ff4444;
        }

        .order-item.matched {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            animation: node-pulse 0.8s ease;
        }

        .order-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .order-price {
            color: #00ff88;
            font-weight: bold;
        }

        .order-price.ask {
            color: #ff4444;
        }

        .order-details {
            color: #999;
            font-size: 0.9em;
        }

        /* CritBit Graph */
        .critbit-graph-panel {
            grid-row: 1 / 2;
        }

        .svg-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            height: 400px;
            overflow: hidden;
            position: relative;
        }

        #critbitSVG {
            width: 100%;
            height: 100%;
        }

        .tree-node-svg {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node-svg:hover {
            filter: brightness(1.3);
        }

        .tree-node-root {
            fill: #00ff88;
        }

        .tree-node-internal {
            fill: #aa00ff;
        }

        .tree-node-leaf {
            fill: #00aaff;
        }

        .tree-edge {
            stroke: rgba(0, 255, 136, 0.5);
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 1000;
            stroke-dashoffset: 0;
        }

        .tree-edge.animated {
            animation: edge-draw 0.6s ease;
        }

        .tree-label {
            fill: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            text-anchor: middle;
        }

        /* Hierarchical Tree */
        .hierarchy-panel {
            grid-row: 1 / 2;
        }

        .tree-hierarchy {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .tree-node-hier {
            margin: 5px 0;
            padding: 8px;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 3px;
            border-left: 3px solid #00ff88;
        }

        .tree-node-hier.root {
            border-left-color: #00ff88;
        }

        .tree-node-hier.internal {
            border-left-color: #aa00ff;
        }

        .tree-node-hier.leaf {
            border-left-color: #00aaff;
        }

        .tree-node-hier .node-label {
            color: #00ff88;
            font-weight: bold;
        }

        .tree-node-hier .node-details {
            color: #999;
            font-size: 0.9em;
            margin-top: 3px;
        }

        .tree-children {
            margin-left: 20px;
            margin-top: 5px;
        }

        /* Transaction Log */
        .log-panel {
            grid-column: 1 / -1;
            grid-row: 2 / 3;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            animation: fade-in 0.3s ease;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.info {
            color: #00aaff;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ffaa00;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 300px 1fr 1fr;
                grid-template-rows: auto auto 1fr;
            }
            .hierarchy-panel {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
            }
            .log-panel {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto;
            }
            .order-entry {
                grid-row: 1 / 2;
                grid-column: 1 / 2;
            }
            .order-book-panel {
                grid-row: 1 / 2;
                grid-column: 2 / 3;
            }
            .critbit-graph-panel {
                grid-row: 2 / 3;
                grid-column: 1 / 3;
            }
            .hierarchy-panel {
                grid-row: 3 / 4;
                grid-column: 1 / 3;
            }
            .log-panel {
                grid-row: 4 / 5;
                grid-column: 1 / 3;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Order Entry Panel -->
        <div class="panel glass-panel order-entry">
            <h3>Place Order</h3>
            
            <!-- Phantom Wallet Connection -->
            <button id="phantomConnectBtn" class="btn" onclick="connectPhantomWallet()" style="background: linear-gradient(135deg, #ab9ff2 0%, #6f5cc6 100%); margin-bottom: 15px;">
                Connect Phantom Wallet
            </button>
            
            <!-- Wallet Role Indicator -->
            <div id="walletRole" class="wallet-role" style="display:none;">
                Role: <span id="walletRoleText">Unknown</span>
            </div>
            
            <!-- Wallet Balance Display -->
            <div id="walletBalance" class="wallet-role" style="display:none;">
                <div>SOL: <span id="solBalance">0</span></div>
                <div>Tokens: <span id="tokenBalance">0</span></div>
            </div>
            
            <!-- ZK Fiat Mode Toggle -->
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                    <span>P2P Fiat Settlement (Stub ZK)</span>
                    <input type="checkbox" id="zkFiatModeToggle" checked style="display: none;">
                    <div class="toggle-switch" id="toggleSwitch">
                        <div class="toggle-slider"></div>
                    </div>
                </label>
                <small style="color: #999; font-size: 0.75em; margin-top: 5px; display: block;">
                    When enabled, matched orders require fiat payment confirmation
                </small>
            </div>
            
            <!-- Token Mint Configuration -->
            <div class="form-group">
                <label>Token Mint Address</label>
                <input type="text" id="tokenMint" placeholder="Token Mint Address (leave blank for default)" value="">
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="statOrders">0</div>
                    <div class="stat-label">Orders</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statMatches">0</div>
                    <div class="stat-label">Matches</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statVolume">0</div>
                    <div class="stat-label">Volume</div>
                </div>
            </div>

            <div class="form-group">
                <label>Trader</label>
                <input type="text" id="trader" placeholder="Trader Name" value="Alice">
            </div>
            
            <div class="form-group">
                <label>Amount</label>
                <input type="number" id="amount" placeholder="100" value="100">
            </div>
            
            <div class="form-group">
                <label>Price</label>
                <input type="number" id="price" placeholder="50" value="50">
            </div>
            
            <div class="form-group">
                <label>Payment Method</label>
                <input type="text" id="payment" placeholder="PayPal" value="PayPal">
            </div>
            
            <div class="form-group">
                <label>Order Type</label>
                <select id="order-type" class="input">
                    <option value="limit">Limit Order</option>
                    <option value="fok">FOK (Fill-or-Kill)</option>
                </select>
            </div>

            <button class="btn btn-ask" onclick="placeAskOrder()">Place Ask</button>
            <button class="btn btn-bid" onclick="placeBidOrder()">Place Bid</button>
            <button class="btn btn-scenario" onclick="matchOrdersOnChain()">Match Orders (On-Chain)</button>
            <button class="btn btn-clear" onclick="clearAll()">Clear All</button>
            
            <!-- P2P Payment Status Section -->
            <div id="paymentSection" class="payment-section">
                <h4>P2P Payment Status</h4>
                <div id="paymentStatus" class="payment-status">Waiting for match...</div>
                <button id="markPaidBtn" class="btn btn-payment" onclick="markPaymentMade()" style="display:none;">
                    Mark Payment Made
                </button>
                <div id="settlementTimer" class="settlement-timer" style="display:none;">
                    Verifying payment (stub ZK)...<br>
                    <div class="countdown"><span id="countdown">10</span>s</div>
                    <small>In production: ZK proof verification would happen here</small>
                </div>
            </div>
        </div>

        <!-- Order Book Panel -->
        <div class="panel glass-panel order-book-panel">
            <h3>Order Book</h3>
            <div class="order-book" id="orderBook">
                <div class="empty-state">No orders in the book</div>
            </div>
        </div>

        <!-- CritBit Graph Panel -->
        <div class="panel glass-panel critbit-graph-panel">
            <h3>CritBit Tree Graph</h3>
            <div class="svg-container">
                <svg id="critbitSVG"></svg>
            </div>
        </div>

        <!-- Hierarchical Tree Panel -->
        <div class="panel glass-panel hierarchy-panel">
            <h3>Tree Structure</h3>
            <div class="tree-hierarchy" id="treeHierarchy">
                <div class="empty-state">Tree visualization will appear here</div>
            </div>
        </div>

        <!-- Transaction Log Panel -->
        <div class="panel glass-panel log-panel">
            <h3>Transaction Log</h3>
            <div class="log-container" id="logContainer">
                <div class="log-entry info">[System] Initialized. Ready to process orders.</div>
            </div>
        </div>
    </div>

    <script>
        // ================= CritBit Tree Implementation =================
        const EMPTY = 0xFFFFFFFF;

        class CritBitNode {
            constructor(isLeaf = false) {
                this.key = 0;
                this.orderIndex = 0;
                this.parent = EMPTY;
                this.left = EMPTY;
                this.right = EMPTY;
                this.prefixLen = 0;
                this.isLeaf = isLeaf;
            }

            static newLeaf(key, orderIndex) {
                const node = new CritBitNode(true);
                node.key = key;
                node.orderIndex = orderIndex;
                return node;
            }

            static newInner(prefixLen) {
                const node = new CritBitNode(false);
                node.prefixLen = prefixLen;
                return node;
            }
        }

        class CritBitTree {
            constructor(capacity = 100) {
                this.nodes = [];
                for (let i = 0; i < capacity; i++) {
                    this.nodes.push(new CritBitNode());
                }
                this.root = EMPTY;
                this.leafCount = 0;
                this.freeList = 0;
            }

            findCriticalBit(key1, key2) {
                const xor = key1 ^ key2;
                if (xor === 0) return 64;
                return 63 - Math.clz32(xor);
            }

            getBit(key, bitPos) {
                if (bitPos >= 64) return false;
                return ((key >> bitPos) & 1) === 1;
            }

            allocNode() {
                if (this.freeList >= this.nodes.length) {
                    throw new Error('OrderBook full');
                }
                return this.freeList++;
            }

            insert(key, orderIndex) {
                // Empty tree case
                if (this.root === EMPTY) {
                    const nodeIndex = this.allocNode();
                    this.nodes[nodeIndex] = CritBitNode.newLeaf(key, orderIndex);
                    this.root = nodeIndex;
                    this.leafCount = 1;
                    log(`[CritBit] Inserted root node at key ${key}`, 'success');
                    return nodeIndex;
                }

                // Find insertion point
                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key === key) {
                            // Update existing
                            this.nodes[current].orderIndex = orderIndex;
                            log(`[CritBit] Updated existing key ${key}`, 'info');
                            return current;
                        }

                        // Find critical bit
                        const critBit = this.findCriticalBit(key, node.key);
                        log(`[CritBit] Critical bit found at position ${critBit}`, 'info');

                        // Create new inner node
                        const innerIndex = this.allocNode();
                        this.nodes[innerIndex] = CritBitNode.newInner(critBit);

                        // Create new leaf
                        const leafIndex = this.allocNode();
                        this.nodes[leafIndex] = CritBitNode.newLeaf(key, orderIndex);

                        // Determine sides
                        const newLeafOnRight = this.getBit(key, critBit);

                        if (newLeafOnRight) {
                            this.nodes[innerIndex].left = current;
                            this.nodes[innerIndex].right = leafIndex;
                        } else {
                            this.nodes[innerIndex].left = leafIndex;
                            this.nodes[innerIndex].right = current;
                        }

                        // Update parent pointers
                        const oldParent = node.parent;
                        this.nodes[current].parent = innerIndex;
                        this.nodes[leafIndex].parent = innerIndex;
                        this.nodes[innerIndex].parent = oldParent;

                        // Update parent's child pointer
                        if (oldParent === EMPTY) {
                            this.root = innerIndex;
                        } else {
                            const parentNode = this.nodes[oldParent];
                            if (parentNode.left === current) {
                                this.nodes[oldParent].left = innerIndex;
                            } else {
                                this.nodes[oldParent].right = innerIndex;
                            }
                        }

                        this.leafCount++;
                        log(`[CritBit] Inserted new leaf at key ${key}`, 'success');
                        return leafIndex;
                    }

                    // Inner node - traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            remove(key) {
                if (this.root === EMPTY) {
                    throw new Error('Order not found');
                }

                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key !== key) {
                            throw new Error('Order not found');
                        }

                        const orderIndex = node.orderIndex;

                        // Single node tree
                        if (node.parent === EMPTY) {
                            this.root = EMPTY;
                            this.leafCount = 0;
                            log(`[CritBit] Removed last node (key ${key})`, 'warning');
                            return orderIndex;
                        }

                        // Get parent and sibling
                        const parentIndex = node.parent;
                        const parent = this.nodes[parentIndex];
                        const siblingIndex = parent.left === current ? parent.right : parent.left;

                        // Update grandparent
                        if (parent.parent === EMPTY) {
                            this.root = siblingIndex;
                            this.nodes[siblingIndex].parent = EMPTY;
                        } else {
                            const grandparentIndex = parent.parent;
                            const grandparent = this.nodes[grandparentIndex];
                            if (grandparent.left === parentIndex) {
                                this.nodes[grandparentIndex].left = siblingIndex;
                            } else {
                                this.nodes[grandparentIndex].right = siblingIndex;
                            }
                            this.nodes[siblingIndex].parent = grandparentIndex;
                        }

                        this.leafCount--;
                        log(`[CritBit] Removed node at key ${key}`, 'warning');
                        return orderIndex;
                    }

                    // Traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            find(key) {
                if (this.root === EMPTY) return null;

                let current = this.root;
                const path = [];

                while (true) {
                    const node = this.nodes[current];
                    path.push(current);

                    if (node.isLeaf) {
                        return node.key === key ? { node, path } : null;
                    }

                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            min() {
                if (this.root === EMPTY) return null;
                return this.findMinInSubtree(this.root);
            }

            findMinInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMin = this.findMinInSubtree(node.left);
                const rightMin = this.findMinInSubtree(node.right);

                if (!leftMin) return rightMin;
                if (!rightMin) return leftMin;

                return leftMin.key < rightMin.key ? leftMin : rightMin;
            }

            max() {
                if (this.root === EMPTY) return null;
                return this.findMaxInSubtree(this.root);
            }

            findMaxInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMax = this.findMaxInSubtree(node.left);
                const rightMax = this.findMaxInSubtree(node.right);

                if (!leftMax) return rightMax;
                if (!rightMax) return leftMax;

                return leftMax.key > rightMax.key ? leftMax : rightMax;
            }
        }

        // ================= Graph Visualizer =================
        class CritBitGraphVisualizer {
            constructor(svgElement) {
                this.svg = svgElement;
                this.width = 0;
                this.height = 0;
                this.updateDimensions();
            }

            updateDimensions() {
                const container = this.svg.parentElement;
                this.width = container.clientWidth;
                this.height = container.clientHeight;
            }

            renderTree(critbitTree) {
                this.svg.innerHTML = '';
                this.updateDimensions();

                if (critbitTree.root === EMPTY) {
                    return;
                }

                // Calculate layout
                const positions = this.calculatePositions(critbitTree);

                // Draw edges first
                this.drawEdges(critbitTree, positions);

                // Draw nodes
                this.drawNodes(critbitTree, positions);
            }

            calculatePositions(tree) {
                const positions = {};
                const levels = {};

                const traverse = (nodeIndex, level, leftBound, rightBound) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const x = (leftBound + rightBound) / 2;
                    const y = 50 + level * 80;

                    positions[nodeIndex] = { x, y };

                    if (!node.isLeaf) {
                        const mid = (leftBound + rightBound) / 2;
                        traverse(node.left, level + 1, leftBound, mid);
                        traverse(node.right, level + 1, mid, rightBound);
                    }
                };

                traverse(tree.root, 0, 0, this.width);
                return positions;
            }

            drawEdges(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (!node.isLeaf) {
                        if (node.left !== EMPTY) {
                            const leftPos = positions[node.left];
                            this.drawEdge(pos.x, pos.y, leftPos.x, leftPos.y);
                            traverse(node.left);
                        }
                        if (node.right !== EMPTY) {
                            const rightPos = positions[node.right];
                            this.drawEdge(pos.x, pos.y, rightPos.x, rightPos.y);
                            traverse(node.right);
                        }
                    }
                };

                traverse(tree.root);
            }

            drawEdge(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('class', 'tree-edge');
                this.svg.appendChild(line);
            }

            drawNodes(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (node.isLeaf) {
                        this.drawLeafNode(pos.x, pos.y, node.key, nodeIndex === tree.root);
                    } else {
                        this.drawInternalNode(pos.x, pos.y, node.prefixLen, nodeIndex === tree.root);
                    }

                    if (!node.isLeaf) {
                        traverse(node.left);
                        traverse(node.right);
                    }
                };

                traverse(tree.root);
            }

            drawLeafNode(x, y, key, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - 30);
                rect.setAttribute('y', y - 15);
                rect.setAttribute('width', 60);
                rect.setAttribute('height', 30);
                rect.setAttribute('rx', 4);
                rect.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-leaf');
                g.appendChild(rect);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `$${key}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }

            drawInternalNode(x, y, prefixLen, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 20);
                circle.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-internal');
                g.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `b${prefixLen}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }
        }

        // ================= Hierarchical View =================
        class HierarchicalView {
            constructor(container) {
                this.container = container;
            }

            renderTree(critbitTree) {
                this.container.innerHTML = '';

                if (critbitTree.root === EMPTY) {
                    this.container.innerHTML = '<div class="empty-state">Tree visualization will appear here</div>';
                    return;
                }

                const html = this.renderNode(critbitTree, critbitTree.root, true);
                this.container.innerHTML = html;
            }

            renderNode(tree, nodeIndex, isRoot = false) {
                if (nodeIndex === EMPTY) return '';

                const node = tree.nodes[nodeIndex];
                const nodeClass = isRoot ? 'root' : (node.isLeaf ? 'leaf' : 'internal');

                let html = `<div class="tree-node-hier ${nodeClass}">`;

                if (node.isLeaf) {
                    html += `<div class="node-label">Leaf: $${node.key}</div>`;
                    html += `<div class="node-details">Order: #${node.orderIndex}</div>`;
                } else {
                    html += `<div class="node-label">Internal: bit ${node.prefixLen}</div>`;
                    html += `<div class="tree-children">`;
                    if (node.left !== EMPTY) {
                        html += this.renderNode(tree, node.left);
                    }
                    if (node.right !== EMPTY) {
                        html += this.renderNode(tree, node.right);
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            }
        }

        // ================= Global State =================
        let orderBook = {
            orders: [],
            last_order_id: 0
        };

        let critbitTree = new CritBitTree(100);
        let graphVisualizer = new CritBitGraphVisualizer(document.getElementById('critbitSVG'));
        let hierarchyView = new HierarchicalView(document.getElementById('treeHierarchy'));

        let totalMatches = 0;
        let totalVolume = 0;

        // ================= Logging =================
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ================= UI Updates =================
        function updateStats() {
            document.getElementById('statOrders').textContent = orderBook.orders.length;
            document.getElementById('statMatches').textContent = totalMatches;
            document.getElementById('statVolume').textContent = totalVolume;
        }

        function renderOrderBook() {
            const container = document.getElementById('orderBook');

            if (orderBook.orders.length === 0) {
                container.innerHTML = '<div class="empty-state">No orders in the book<br><small>Connect wallet and place orders to see them here</small></div>';
                return;
            }

            const sortedOrders = [...orderBook.orders].sort((a, b) => {
                const priceCmp = a.price - b.price;
                if (priceCmp !== 0) return priceCmp;
                return a.created_at - b.created_at;
            });

            container.innerHTML = sortedOrders.map(order => {
                const ownerDisplay = order.owner 
                    ? `${order.owner.slice(0, 4)}...${order.owner.slice(-4)}`
                    : (order.trader || 'Unknown');
                
                const explorerLink = order.tx_signature 
                    ? `<a href="https://explorer.solana.com/tx/${order.tx_signature}?cluster=devnet" target="_blank" style="color: #00aaff; text-decoration: none;">View TX</a>`
                    : '';

                return `
                    <div class="order-item ${order.side}">
                        <div class="order-meta">
                            <span><strong>#${order.order_id}</strong></span>
                            <span class="order-price ${order.side}">$${order.price}</span>
                            <button onclick="cancelOrder(${order.order_id})" class="btn-cancel">Cancel</button>
                        </div>
                        <div class="order-details">
                            ${order.side.toUpperCase()}: ${ownerDisplay} | ${order.amount} tokens
                            ${order.order_type ? `| ${order.order_type}` : ''}
                            ${explorerLink ? `<br>${explorerLink}` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateVisualization() {
            graphVisualizer.renderTree(critbitTree);
            hierarchyView.renderTree(critbitTree);
        }

        // ================= Order Placement =================
        async function placeAskOrder() {
            if (!phantomWallet || !connectedPubkey) {
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);
            const paymentMethod = document.getElementById('payment').value || 'PayPal';
            const tokenMintStr = document.getElementById('tokenMint').value.trim();

            if (!amount || !price) {
                log('[Error] Amount and price are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            if (!tokenMintStr) {
                log('[Error] Token mint address is required', 'error');
                return;
            }

            const orderType = document.getElementById('order-type').value || 'limit';
            
            log(`[Order] Placing ASK: ${amount} @ $${price}...`, 'info');

            try {
                // Build and send on-chain transaction
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig?.programId || 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB');
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);
                
                // Get user's token account (ATA)
                const userTokenAccount = await window.ZK2P.getOrCreateTokenAccount(connection, wallet, tokenMint);
                
                const orderTypeValue = orderType === 'fok' ? 4 : 0; // 0 = Limit, 4 = FOK
                
                const transaction = await window.ZK2P.createPlaceOrderTransaction({
                    connection,
                    programId,
                    wallet,
                    tokenMint,
                    userTokenAccount,
                    side: 'ask',
                    price,
                    quantity: amount,
                    orderType: orderTypeValue,
                    paymentMethod
                });

                // Sign and send via Phantom
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log(`[Transaction] Sent! Confirming...`, 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log(`[Success] ASK order placed on-chain!`, 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');
                
                // Refresh order book after short delay
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);
                
            } catch (error) {
                log(`[Error] Failed to place order: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function placeBidOrder() {
            if (!phantomWallet || !connectedPubkey) {
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);
            const paymentMethod = document.getElementById('payment').value || 'PayPal';
            const tokenMintStr = document.getElementById('tokenMint').value.trim();

            if (!amount || !price) {
                log('[Error] Amount and price are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            if (!tokenMintStr) {
                log('[Error] Token mint address is required', 'error');
                return;
            }

            const orderType = document.getElementById('order-type').value || 'limit';
            
            log(`[Order] Placing BID: ${amount} @ $${price}...`, 'info');

            try {
                // Build and send on-chain transaction
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig?.programId || 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB');
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);
                
                // Get user's token account (ATA)
                const userTokenAccount = await window.ZK2P.getOrCreateTokenAccount(connection, wallet, tokenMint);
                
                const orderTypeValue = orderType === 'fok' ? 4 : 0; // 0 = Limit, 4 = FOK
                
                const transaction = await window.ZK2P.createPlaceOrderTransaction({
                    connection,
                    programId,
                    wallet,
                    tokenMint,
                    userTokenAccount,
                    side: 'bid',
                    price,
                    quantity: amount,
                    orderType: orderTypeValue,
                    paymentMethod
                });

                // Sign and send via Phantom
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log(`[Transaction] Sent! Confirming...`, 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log(`[Success] BID order placed on-chain!`, 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');
                
                // Refresh order book after short delay
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);
                
            } catch (error) {
                log(`[Error] Failed to place order: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function executeLimitBid(trader, amount, price, matchingAsks) {
            // 1:1 MATCHING - Only match against FIRST compatible ask
            if (matchingAsks.length === 0) {
                log('[Limit] No matching orders found', 'error');
                return;
            }

            // Match against FIRST ask only (1:1 buyer:seller)
            const askOrder = matchingAsks[0];
            const fillAmount = Math.min(amount, askOrder.amount);
            
            log(`[Match] 1:1 - ${fillAmount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += fillAmount;

            // Update ask order
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                orderBook.orders[orderIndex].amount -= fillAmount;
                if (orderBook.orders[orderIndex].amount <= 0) {
                    critbitTree.remove(askOrder.price);
                    orderBook.orders.splice(orderIndex, 1);
                    log(`[CritBit] Removed ask order #${askOrder.order_id}`, 'info');
                }
            }

            const remaining = amount - fillAmount;
            log(`[Limit] Matched ${fillAmount}/${amount} tokens (1:1 single seller)`, 'success');
            
            // Show payment section for P2P settlement
            if (window.ZK2P && window.ZK2P.showPaymentSection) {
                // Determine if current user is buyer (placing bid) or seller (had ask order)
                const isBuyer = true; // User placing bid is the buyer
                window.ZK2P.showPaymentSection(isBuyer, askOrder.order_id);
            }

            // If remaining, add as resting limit order
            if (remaining > 0) {
                orderBook.last_order_id++;
                const restingBid = {
                    trader,
                    amount: remaining,
                    price,
                    side: 'bid',
                    order_type: 'limit',
                    created_at: Date.now(),
                    order_id: orderBook.last_order_id
                };
                orderBook.orders.push(restingBid);
                critbitTree.insert(price, orderBook.last_order_id);
                log(`[Limit] Resting bid added: ${remaining} @ $${price}`, 'info');
            }
        }

        function executeFOKBid(trader, amount, price, matchingAsks, totalAvailable) {
            // FOK: Must match EXACTLY with single ask (1:1 + exact amount)
            if (matchingAsks.length === 0) {
                log('[FOK] No matching orders - REJECTED', 'error');
                return;
            }

            // Check if FIRST ask can fill the EXACT amount
            const askOrder = matchingAsks[0];
            
            if (askOrder.amount !== amount) {
                log('[FOK] Cannot fill exactly - REJECTED', 'error');
                log(`[FOK] Need exactly ${amount}, but first ask has ${askOrder.amount}`, 'error');
                return;
            }

            // Perfect match - fill completely
            log(`[Match] 1:1 FOK - ${amount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += amount;

            // Remove ask order completely
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                critbitTree.remove(askOrder.price);
                orderBook.orders.splice(orderIndex, 1);
            }

            log(`[FOK] Filled ${amount}/${amount} tokens exactly (1:1 perfect match)`, 'success');
        }

        function cancelOrder(orderId) {
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === orderId);
            if (orderIndex === -1) {
                log(`[Error] Order #${orderId} not found`, 'error');
                return;
            }
            
            const order = orderBook.orders[orderIndex];
            
            // Remove from CritBit tree if this was the last order at this price
            const ordersAtPrice = orderBook.orders.filter(o => o.price === order.price && o.order_id !== orderId);
            if (ordersAtPrice.length === 0) {
                try {
                    critbitTree.remove(order.price);
                    log(`[CritBit] Removed price level ${order.price} from tree`, 'info');
                } catch (e) {
                    log(`[CritBit] ${e.message}`, 'warning');
                }
            }
            
            // Remove from order book
            orderBook.orders.splice(orderIndex, 1);
            
            log(`[Cancel] Order #${orderId} cancelled: ${order.trader}, ${order.amount} @ $${order.price}`, 'warning');
            
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        function clearAll() {
            orderBook.orders = [];
            orderBook.last_order_id = 0;
            totalMatches = 0;
            totalVolume = 0;
            critbitTree = new CritBitTree(100);
            log('[System] All orders cleared', 'warning');
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        // ================= Match Orders On-Chain =================
        async function matchOrdersOnChain() {
            if (!phantomWallet || !connectedPubkey) {
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            if (!appConfig) {
                log('[Error] Config not loaded', 'error');
                return;
            }

            const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
            const amount = parseInt(document.getElementById('amount').value) || 100;
            const price = parseInt(document.getElementById('price').value) || 50;
            const orderType = document.getElementById('order-type')?.value || 'limit';

            log('[Match] Attempting to match orders on-chain...', 'info');

            try {
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);

                // Derive OrderBook PDA
                const [orderBook] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('order_book'), tokenMint.toBuffer()],
                    programId
                );

                // Build match_order instruction using discriminator from onchain-transactions.js
                // Instruction data: discriminator (8 bytes) + side (1 byte) + quantity (8 bytes) + limit_price (8 bytes) + order_type (1 byte)
                const instructionData = Buffer.alloc(26);
                
                // Use MATCH_ORDER discriminator from window.ZK2P.INSTRUCTIONS if available
                let matchDiscriminator;
                if (window.ZK2P && window.ZK2P.INSTRUCTIONS && window.ZK2P.INSTRUCTIONS.MATCH_ORDER) {
                    matchDiscriminator = window.ZK2P.INSTRUCTIONS.MATCH_ORDER;
                } else {
                    // Fallback discriminator
                    matchDiscriminator = Buffer.from([0x65, 0x4c, 0x8a, 0x9f, 0x23, 0x7d, 0x1e, 0xb2]);
                }
                
                matchDiscriminator.copy(instructionData, 0);
                instructionData.writeUInt8(0, 8); // Side: 0 = Bid (buyer matching against asks)
                instructionData.writeBigUInt64LE(BigInt(amount), 9); // Quantity
                instructionData.writeBigUInt64LE(BigInt(price), 17); // Limit price
                
                // Order type: 0 = Limit, 4 = FOK
                const orderTypeValue = orderType === 'fok' ? 4 : 0;
                instructionData.writeUInt8(orderTypeValue, 25);

                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: wallet, isSigner: true, isWritable: true }, // owner (matcher)
                        { pubkey: orderBook, isSigner: false, isWritable: true }, // order_book
                        { pubkey: tokenMint, isSigner: false, isWritable: false }, // token_mint
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false }, // system_program
                    ],
                    programId,
                    data: instructionData
                });

                const transaction = new solanaWeb3.Transaction().add(instruction);
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = wallet;

                // Sign and send
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log('[Transaction] Match sent! Confirming...', 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log('[Success] Orders matched on-chain!', 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');

                // Determine buyer/seller role
                // If connected wallet matches buyer address, they are buyer; otherwise seller
                const isBuyer = connectedPubkey === appConfig.buyerAddress || 
                                connectedPubkey !== appConfig.sellerAddress;
                
                // Generate order_id for payment tracking (use timestamp as order_id)
                const matchedOrderId = Date.now();
                
                // Store matched order details globally
                window.currentMatchedOrder = {
                    order_id: matchedOrderId,
                    side: isBuyer ? 'bid' : 'ask',
                    amount: amount,
                    price: price,
                    counterparty: isBuyer ? appConfig.sellerAddress : appConfig.buyerAddress,
                    tx_signature: signature
                };

                // Create matched order in OrderStore (Pending state)
                if (appConfig.orderStoreProgramId && window.ZK2P && window.ZK2P.createMatchedOrderTransaction) {
                    try {
                        const orderStoreProgramId = new solanaWeb3.PublicKey(appConfig.orderStoreProgramId);
                        const { transaction: createOrderTx, matchedOrder } = await window.ZK2P.createMatchedOrderTransaction({
                            connection,
                            orderStoreProgramId,
                            wallet,
                            orderId: matchedOrderId,
                            bidder: isBuyer ? connectedPubkey : appConfig.buyerAddress,
                            seller: isBuyer ? appConfig.sellerAddress : connectedPubkey,
                            tokenMint,
                            amount,
                            price
                        });
                        
                        const createOrderSignature = await phantomWallet.signAndSendTransaction(createOrderTx);
                        await connection.confirmTransaction(createOrderSignature, 'confirmed');
                        
                        log('[OrderStore] Matched order created (Pending state)', 'success');
                        log(`[OrderStore PDA] ${matchedOrder.toString()}`, 'info');
                        log(`[Explorer] https://explorer.solana.com/tx/${createOrderSignature}?cluster=devnet`, 'info');
                    } catch (orderStoreError) {
                        log(`[OrderStore] Warning: Could not create matched order: ${orderStoreError.message}`, 'warning');
                        console.warn('OrderStore create error:', orderStoreError);
                    }
                }

                // If ZK Fiat Mode enabled, show payment section
                if (window.zkFiatModeEnabled && window.ZK2P && window.ZK2P.showPaymentSection) {
                    window.ZK2P.showPaymentSection(isBuyer, matchedOrderId);
                } else if (!window.zkFiatModeEnabled) {
                    log('[Match] ZK Fiat Mode disabled - Trade settled immediately', 'info');
                }

                // Refresh order book
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);

            } catch (error) {
                log(`[Error] Match failed: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // ================= Fetch On-Chain OrderBook State =================
        window.fetchOrderBookState = async function() {
            if (!appConfig || !appConfig.defaultTokenMint) {
                log('[OrderBook] Config not loaded yet', 'warning');
                return;
            }

            try {
                const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);

                // Derive OrderBook PDA
                const [orderBookPda] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('order_book'), tokenMint.toBuffer()],
                    programId
                );

                // Fetch account data
                const accountInfo = await connection.getAccountInfo(orderBookPda);
                if (!accountInfo) {
                    log('[OrderBook] Account not found - needs initialization', 'warning');
                    orderBook.orders = [];
                    renderOrderBook();
                    return;
                }

                log('[OrderBook] Fetched on-chain data successfully', 'success');

                // Load IDL and deserialize using Anchor
                try {
                    const idlResponse = await fetch('market.json');
                    const idl = await idlResponse.json();
                    
                    // Ensure Anchor is available (try multiple possible global names)
                    const Anchor = window.anchor || window.Anchor || anchor;
                    if (!Anchor) {
                        throw new Error('Anchor library not loaded');
                    }
                    
                    // Create Anchor program instance
                    const program = new Anchor.Program(idl, programId, {
                        connection: connection
                    });
                    
                    // Deserialize OrderBook account (Anchor handles discriminator automatically)
                    // Account data starts with 8-byte discriminator, which Anchor's decoder handles
                    const orderBookAccount = program.account.orderBook.coder.accounts.decode(
                        'OrderBook',
                        accountInfo.data
                    );
                    
                    // Log deserialized data structure
                    console.log('[OrderBook] Deserialized account:', orderBookAccount);
                    
                    // Extract property names (Anchor converts snake_case to camelCase)
                    const totalOrders = orderBookAccount.totalOrders || orderBookAccount.total_orders || 0;
                    const bestBid = orderBookAccount.bestBid || orderBookAccount.best_bid || 0;
                    const bestAsk = orderBookAccount.bestAsk || orderBookAccount.best_ask || 0;
                    const orderQueues = orderBookAccount.orderQueues || orderBookAccount.order_queues || [];
                    
                    log(`[OrderBook] Deserialized - Total orders: ${totalOrders}`, 'info');
                    log(`[OrderBook] Best bid: ${bestBid}, Best ask: ${bestAsk}`, 'info');
                    log(`[OrderBook] Order queues: ${orderQueues.length}`, 'info');
                    
                    // Extract all orders from order_queues
                    const allOrders = [];
                    if (Array.isArray(orderQueues)) {
                        for (const queue of orderQueues) {
                            const orders = queue.orders || [];
                            if (Array.isArray(orders)) {
                                for (const order of orders) {
                                    // Convert Anchor types to UI format
                                    // Handle both camelCase and snake_case property names
                                    const orderId = order.orderId || order.order_id;
                                    const owner = order.owner;
                                    const quantity = order.quantity || 0;
                                    const price = order.price || 0;
                                    const side = order.side;
                                    const orderType = order.orderType || order.order_type;
                                    const timestamp = order.timestamp || 0;
                                    const paymentStatus = order.paymentStatus || order.payment_status;
                                    
                                    // Parse side enum
                                    let sideStr = 'unknown';
                                    if (side) {
                                        if (side.bid !== undefined || side === 'Bid' || side === 0) {
                                            sideStr = 'bid';
                                        } else if (side.ask !== undefined || side === 'Ask' || side === 1) {
                                            sideStr = 'ask';
                                        }
                                    }
                                    
                                    // Parse order type enum
                                    let orderTypeStr = 'limit';
                                    if (orderType) {
                                        if (orderType.limit !== undefined || orderType === 'Limit' || orderType === 0) {
                                            orderTypeStr = 'limit';
                                        } else if (orderType.fillOrKill !== undefined || orderType === 'FillOrKill' || orderType === 4) {
                                            orderTypeStr = 'fok';
                                        }
                                    }
                                    
                                    // Parse payment status
                                    let paymentStatusStr = 'Pending';
                                    if (paymentStatus) {
                                        if (paymentStatus.pending !== undefined || paymentStatus === 'Pending' || paymentStatus === 0) {
                                            paymentStatusStr = 'Pending';
                                        } else if (paymentStatus.paymentMarked !== undefined || paymentStatus === 'PaymentMarked' || paymentStatus === 1) {
                                            paymentStatusStr = 'PaymentMarked';
                                        } else if (paymentStatus.verified !== undefined || paymentStatus === 'Verified' || paymentStatus === 3) {
                                            paymentStatusStr = 'Verified';
                                        }
                                    }
                                    
                                    const uiOrder = {
                                        order_id: orderId ? orderId.toString() : '0',
                                        owner: owner ? owner.toString() : '',
                                        amount: Number(quantity),
                                        price: Number(price),
                                        side: sideStr,
                                        order_type: orderTypeStr,
                                        timestamp: Number(timestamp),
                                        payment_status: paymentStatusStr,
                                        created_at: Number(timestamp) * 1000 || Date.now(),
                                        trader: owner ? `${owner.toString().slice(0, 4)}...${owner.toString().slice(-4)}` : 'Unknown'
                                    };
                                    allOrders.push(uiOrder);
                                }
                            }
                        }
                    }
                    
                    // Update local order book state
                    orderBook.orders = allOrders;
                    log(`[OrderBook] Extracted ${allOrders.length} orders from on-chain data`, 'success');
                    
                    // Update UI
                    renderOrderBook();
                    updateStats();
                    
                } catch (deserializeError) {
                    log(`[OrderBook] Deserialization error: ${deserializeError.message}`, 'error');
                    console.error('Deserialization error:', deserializeError);
                    console.error('Error stack:', deserializeError.stack);
                    // Fallback: just show that we fetched the data
                    renderOrderBook();
                }
                
            } catch (error) {
                log(`[OrderBook] Error fetching: ${error.message}`, 'error');
                console.error(error);
            }
        };

        // Initialize
        updateStats();
        window.addEventListener('resize', () => updateVisualization());
        
        // Auto-refresh OrderBook every 5 seconds if wallet connected
        setInterval(async () => {
            if (phantomWallet && connectedPubkey && appConfig) {
                await window.fetchOrderBookState();
            }
        }, 5000);
    </script>

    <!-- Buffer Polyfill for Browser -->
    <!-- Buffer polyfill - MUST load first -->
    <script src="https://unpkg.com/buffer@6.0.3/index.js"></script>
    <script>
        // Make Buffer available globally IMMEDIATELY
        if (typeof buffer !== 'undefined' && buffer.Buffer) {
            window.Buffer = buffer.Buffer;
            console.log('[Buffer] Polyfill loaded successfully');
        } else {
            console.error('[Buffer] Failed to load polyfill');
        }
    </script>
    
    <!-- Solana Web3.js and Wallet Adapter -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@coral-xyz/anchor@0.29.0/dist/browser/index.js"></script>
    
    <!-- Phantom Wallet Integration -->
    <script>
        // Solana Web3 Configuration
        const DEVNET_RPC = 'https://api.devnet.solana.com';
        const connection = new solanaWeb3.Connection(DEVNET_RPC, 'confirmed');
        
        // Deployed Program IDs on Devnet
        const PROGRAM_IDS = {
            market: 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB',
            orderStore: '9eVsFt83o3qkfaKNMZ6wuom2HL6ScB9sF3NikzDnxrNb',
            orderProcessor: 'Gn8GGrCgmBQs4tRvf2oeWXjgsqHBcYByDhQiAxGdfFqV'
        };
        
        let phantomWallet = null;
        let connectedPubkey = null;
        
        // Detect and connect to Phantom
        async function detectPhantom() {
            const isPhantomInstalled = window.solana && window.solana.isPhantom;
            
            if (!isPhantomInstalled) {
                log('[Wallet] Phantom wallet not detected. Please install from phantom.app', 'error');
                return false;
            }
            
            log('[Wallet] Phantom detected', 'success');
            return true;
        }
        
        let appConfig = null;
        
        async function connectPhantomWallet() {
            try {
                if (!await detectPhantom()) {
                    window.open('https://phantom.app/', '_blank');
                    return;
                }
                
                const resp = await window.solana.connect();
                connectedPubkey = resp.publicKey.toString();
                phantomWallet = window.solana;
                
                log(`[Wallet] Connected: ${connectedPubkey.slice(0, 8)}...${connectedPubkey.slice(-8)}`, 'success');
                
                // Load config.json
                try {
                    const configResp = await fetch('config.json');
                    appConfig = await configResp.json();
                    
                    // Populate token mint input with default if empty
                    const tokenMintInput = document.getElementById('tokenMint');
                    if (tokenMintInput && !tokenMintInput.value) {
                        tokenMintInput.value = appConfig.defaultTokenMint;
                    }
                    
                    log('[Config] Loaded config.json successfully', 'success');
                } catch (err) {
                    log(`[Config] Warning: Could not load config.json - ${err.message}`, 'warning');
                }
                
                // Update UI with connected wallet
                const walletBtn = document.getElementById('phantomConnectBtn');
                if (walletBtn) {
                    walletBtn.textContent = `Connected: ${connectedPubkey.slice(0, 4)}...${connectedPubkey.slice(-4)}`;
                    walletBtn.style.background = 'linear-gradient(135deg, #00ff88, #00aa55)';
                }
                
                // Update balances display
                await updateBalances();
                
                // Identify wallet role (seller or buyer)
                if (window.ZK2P && window.ZK2P.identifyWalletRole) {
                    await window.ZK2P.identifyWalletRole();
                }
                
                // Check initialization status
                await checkInitialization();
                
                // Fetch order book state after connection
                if (window.fetchOrderBookState) {
                    setTimeout(() => window.fetchOrderBookState(), 1000);
                }
                
                return true;
            } catch (err) {
                log(`[Wallet] Connection failed: ${err.message}`, 'error');
                return false;
            }
        }
        
        // Disconnect wallet
        async function disconnectPhantom() {
            if (phantomWallet) {
                await phantomWallet.disconnect();
                connectedPubkey = null;
                phantomWallet = null;
                log('[Wallet] Disconnected', 'info');
            }
        }
        
        // Update wallet balances (SOL and token)
        async function updateBalances() {
            if (!connectedPubkey) return;
            
            try {
                // Get SOL balance
                const solBalance = await connection.getBalance(new solanaWeb3.PublicKey(connectedPubkey));
                document.getElementById('solBalance').textContent = (solBalance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                log(`[Wallet] Balance: ${(solBalance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL`, 'info');
                
                // Get token balance if ATA exists
                try {
                    const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                    if (tokenMintStr) {
                        const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                        const ata = await window.ZK2P.getOrCreateTokenAccount(connection, new solanaWeb3.PublicKey(connectedPubkey), tokenMint);
                        const tokenAccount = await connection.getTokenAccountBalance(ata);
                        document.getElementById('tokenBalance').textContent = tokenAccount.value.uiAmount || 0;
                        log(`[Wallet] Token balance: ${tokenAccount.value.uiAmount || 0}`, 'info');
                    }
                } catch (e) {
                    document.getElementById('tokenBalance').textContent = '0';
                    log('[Wallet] No token balance found (ATA may not exist yet)', 'warning');
                }
                
                // Show balance display
                document.getElementById('walletBalance').style.display = 'block';
            } catch (error) {
                log(`[Wallet] Error fetching balances: ${error.message}`, 'error');
            }
        }
        
        // Check if on-chain accounts are initialized
        async function checkInitialization() {
            try {
                const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                if (!tokenMintStr) {
                    log('[Init] No token mint specified', 'warning');
                    return false;
                }
                
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);
                
                // Check Market
                const [market] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('market'), tokenMint.toBuffer()],
                    programId
                );
                const marketInfo = await connection.getAccountInfo(market);
                if (!marketInfo) {
                    log('[Init] Market not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] Market account ', 'success');
                
                // Check OrderBook
                const [orderBook] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('order_book'), tokenMint.toBuffer()],
                    programId
                );
                const orderBookInfo = await connection.getAccountInfo(orderBook);
                if (!orderBookInfo) {
                    log('[Init] OrderBook not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] OrderBook account ', 'success');
                
                // Check EscrowVault
                const [escrowVault] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('escrow_vault'), tokenMint.toBuffer()],
                    programId
                );
                const vaultInfo = await connection.getAccountInfo(escrowVault);
                if (!vaultInfo) {
                    log('[Init] Escrow vault not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] Escrow vault ', 'success');
                
                log('[Init] All accounts initialized ', 'success');
                return true;
            } catch (error) {
                log(`[Init] Error checking initialization: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Initialize Phantom connection on page load
        window.addEventListener('load', async () => {
            await detectPhantom();
            
            // Auto-connect if previously authorized
            if (window.solana && window.solana.isConnected) {
                await connectPhantomWallet();
            }
        });
        
        // Handle account changes
        if (window.solana) {
            window.solana.on('accountChanged', (publicKey) => {
                if (publicKey) {
                    connectedPubkey = publicKey.toString();
                    log(`[Wallet] Account changed to ${connectedPubkey.slice(0, 8)}...`, 'info');
                } else {
                    disconnectPhantom();
                }
            });
        }
        
        console.log('[2k2Peer] Phantom wallet integration ready');
        console.log('[2k2Peer] Market Program ID:', PROGRAM_IDS.market);
        console.log('[2k2Peer] P2P Payment status tracking enabled');
    </script>
    
    <!-- ZK Fiat Mode Toggle Logic -->
    <script>
        // Initialize ZK Fiat Mode state
        window.zkFiatModeEnabled = true;
        
        // Setup toggle switch functionality
        document.addEventListener('DOMContentLoaded', () => {
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleCheckbox = document.getElementById('zkFiatModeToggle');
            
            // Set initial state
            if (toggleCheckbox.checked) {
                toggleSwitch.classList.add('active');
            }
            
            // Handle toggle click
            toggleSwitch.addEventListener('click', () => {
                toggleCheckbox.checked = !toggleCheckbox.checked;
                window.zkFiatModeEnabled = toggleCheckbox.checked;
                
                if (toggleCheckbox.checked) {
                    toggleSwitch.classList.add('active');
                    log('[ZK Fiat Mode] Enabled - P2P payment flow active', 'success');
                } else {
                    toggleSwitch.classList.remove('active');
                    log('[ZK Fiat Mode] Disabled - Direct settlement', 'warning');
                }
            });
            
            log('[ZK Fiat Mode] Initialized - Mode: ' + (window.zkFiatModeEnabled ? 'Enabled' : 'Disabled'), 'info');
        });
    </script>
    
    <!-- On-chain Transaction Integration -->
    <script src="onchain-transactions.js"></script>
</body>
</html>
