<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2k2Peer - DEX Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Glassmorphism Effects */
        .glass-panel {
            background: rgba(26, 26, 26, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.1);
        }

        .neon-glow {
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5),
                        0 0 20px rgba(0, 255, 136, 0.3),
                        0 0 30px rgba(0, 255, 136, 0.2);
        }

        .neon-glow-blue {
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.5),
                        0 0 20px rgba(0, 170, 255, 0.3);
        }

        .neon-glow-purple {
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5),
                        0 0 20px rgba(170, 0, 255, 0.3);
        }

        /* Animations */
        @keyframes node-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes edge-draw {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes glow-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        /* Layout */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 20px;
            min-height: 100vh;
        }

        .panel {
            padding: 20px;
            overflow: hidden;
            animation: fade-in 0.5s ease;
        }

        .panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Order Entry Panel */
        .order-entry {
            grid-row: 1 / 3;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-ask {
            background: linear-gradient(135deg, #ff4444 0%, #cc3333 100%);
            color: #fff;
        }

        .btn-ask:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .btn-bid {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
        }

        .btn-bid:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .btn-clear {
            background: rgba(102, 102, 102, 0.5);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-clear:hover {
            background: rgba(136, 136, 136, 0.5);
        }

        .btn-cancel {
            background: #ff4444;
            color: white;
            border: none;
            padding: 3px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 8px;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background: #ff6666;
            transform: scale(1.05);
        }

        .btn-scenario {
            background: rgba(0, 170, 255, 0.3);
            color: white;
            border: 1px solid rgba(0, 170, 255, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 8px;
            width: 100%;
            transition: all 0.2s;
        }

        .btn-scenario:hover {
            background: rgba(0, 170, 255, 0.5);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.4);
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 0.7em;
            color: #999;
            margin-top: 3px;
            text-transform: uppercase;
        }

        /* Order Book */
        .order-book-panel {
            grid-row: 1 / 2;
        }

        .order-book {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .order-item {
            background: rgba(26, 26, 26, 0.8);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            font-size: 0.85em;
            animation: fade-in 0.3s ease;
        }

        .order-item.ask {
            border-left-color: #ff4444;
        }

        .order-item.matched {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            animation: node-pulse 0.8s ease;
        }

        .order-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .order-price {
            color: #00ff88;
            font-weight: bold;
        }

        .order-price.ask {
            color: #ff4444;
        }

        .order-details {
            color: #999;
            font-size: 0.9em;
        }

        /* CritBit Graph */
        .critbit-graph-panel {
            grid-row: 1 / 2;
        }

        .svg-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            height: 400px;
            overflow: hidden;
            position: relative;
        }

        #critbitSVG {
            width: 100%;
            height: 100%;
        }

        .tree-node-svg {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node-svg:hover {
            filter: brightness(1.3);
        }

        .tree-node-root {
            fill: #00ff88;
        }

        .tree-node-internal {
            fill: #aa00ff;
        }

        .tree-node-leaf {
            fill: #00aaff;
        }

        .tree-edge {
            stroke: rgba(0, 255, 136, 0.5);
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 1000;
            stroke-dashoffset: 0;
        }

        .tree-edge.animated {
            animation: edge-draw 0.6s ease;
        }

        .tree-label {
            fill: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            text-anchor: middle;
        }

        /* Hierarchical Tree */
        .hierarchy-panel {
            grid-row: 1 / 2;
        }

        .tree-hierarchy {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .tree-node-hier {
            margin: 5px 0;
            padding: 8px;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 3px;
            border-left: 3px solid #00ff88;
        }

        .tree-node-hier.root {
            border-left-color: #00ff88;
        }

        .tree-node-hier.internal {
            border-left-color: #aa00ff;
        }

        .tree-node-hier.leaf {
            border-left-color: #00aaff;
        }

        .tree-node-hier .node-label {
            color: #00ff88;
            font-weight: bold;
        }

        .tree-node-hier .node-details {
            color: #999;
            font-size: 0.9em;
            margin-top: 3px;
        }

        .tree-children {
            margin-left: 20px;
            margin-top: 5px;
        }

        /* Transaction Log */
        .log-panel {
            grid-column: 1 / -1;
            grid-row: 2 / 3;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            animation: fade-in 0.3s ease;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.info {
            color: #00aaff;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ffaa00;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 300px 1fr 1fr;
                grid-template-rows: auto auto 1fr;
            }
            .hierarchy-panel {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
            }
            .log-panel {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto;
            }
            .order-entry {
                grid-row: 1 / 2;
                grid-column: 1 / 2;
            }
            .order-book-panel {
                grid-row: 1 / 2;
                grid-column: 2 / 3;
            }
            .critbit-graph-panel {
                grid-row: 2 / 3;
                grid-column: 1 / 3;
            }
            .hierarchy-panel {
                grid-row: 3 / 4;
                grid-column: 1 / 3;
            }
            .log-panel {
                grid-row: 4 / 5;
                grid-column: 1 / 3;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Order Entry Panel -->
        <div class="panel glass-panel order-entry">
            <h3>Place Order</h3>
            
            <!-- Phantom Wallet Connection Button -->
            <button id="phantomConnectBtn" class="btn" onclick="connectPhantomWallet()" style="background: linear-gradient(135deg, #ab9ff2 0%, #6f5cc6 100%); margin-bottom: 15px; cursor: pointer;">
                🔗 Connect Phantom Wallet
            </button>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="statOrders">0</div>
                    <div class="stat-label">Orders</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statMatches">0</div>
                    <div class="stat-label">Matches</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statVolume">0</div>
                    <div class="stat-label">Volume</div>
                </div>
            </div>

            <div class="form-group">
                <label>Trader</label>
                <input type="text" id="trader" placeholder="Trader Name" value="Alice">
            </div>
            
            <div class="form-group">
                <label>Amount</label>
                <input type="number" id="amount" placeholder="100" value="100">
            </div>
            
            <div class="form-group">
                <label>Price</label>
                <input type="number" id="price" placeholder="50" value="50">
            </div>
            
            <div class="form-group">
                <label>Payment Method</label>
                <input type="text" id="payment" placeholder="PayPal" value="PayPal">
            </div>
            
            <div class="form-group">
                <label>Order Type</label>
                <select id="order-type" class="input">
                    <option value="limit">Limit Order</option>
                    <option value="fok">FOK (Fill-or-Kill)</option>
                </select>
            </div>

            <button class="btn btn-ask" onclick="placeAskOrder()">Place Ask</button>
            <button class="btn btn-bid" onclick="placeBidOrder()">Place Bid</button>
            <button class="btn btn-clear" onclick="clearAll()">Clear All</button>
        </div>

        <!-- Order Book Panel -->
        <div class="panel glass-panel order-book-panel">
            <h3>Order Book</h3>
            <div class="order-book" id="orderBook">
                <div class="empty-state">No orders in the book</div>
            </div>
        </div>

        <!-- CritBit Graph Panel -->
        <div class="panel glass-panel critbit-graph-panel">
            <h3>CritBit Tree Graph</h3>
            <div class="svg-container">
                <svg id="critbitSVG"></svg>
            </div>
        </div>

        <!-- Hierarchical Tree Panel -->
        <div class="panel glass-panel hierarchy-panel">
            <h3>Tree Structure</h3>
            <div class="tree-hierarchy" id="treeHierarchy">
                <div class="empty-state">Tree visualization will appear here</div>
            </div>
        </div>

        <!-- Transaction Log Panel -->
        <div class="panel glass-panel log-panel">
            <h3>Transaction Log</h3>
            <div class="log-container" id="logContainer">
                <div class="log-entry info">[System] Initialized. Ready to process orders.</div>
            </div>
        </div>
    </div>

    <script>
        // ================= CritBit Tree Implementation =================
        const EMPTY = 0xFFFFFFFF;

        class CritBitNode {
            constructor(isLeaf = false) {
                this.key = 0;
                this.orderIndex = 0;
                this.parent = EMPTY;
                this.left = EMPTY;
                this.right = EMPTY;
                this.prefixLen = 0;
                this.isLeaf = isLeaf;
            }

            static newLeaf(key, orderIndex) {
                const node = new CritBitNode(true);
                node.key = key;
                node.orderIndex = orderIndex;
                return node;
            }

            static newInner(prefixLen) {
                const node = new CritBitNode(false);
                node.prefixLen = prefixLen;
                return node;
            }
        }

        class CritBitTree {
            constructor(capacity = 100) {
                this.nodes = [];
                for (let i = 0; i < capacity; i++) {
                    this.nodes.push(new CritBitNode());
                }
                this.root = EMPTY;
                this.leafCount = 0;
                this.freeList = 0;
            }

            findCriticalBit(key1, key2) {
                const xor = key1 ^ key2;
                if (xor === 0) return 64;
                return 63 - Math.clz32(xor);
            }

            getBit(key, bitPos) {
                if (bitPos >= 64) return false;
                return ((key >> bitPos) & 1) === 1;
            }

            allocNode() {
                if (this.freeList >= this.nodes.length) {
                    throw new Error('OrderBook full');
                }
                return this.freeList++;
            }

            insert(key, orderIndex) {
                // Empty tree case
                if (this.root === EMPTY) {
                    const nodeIndex = this.allocNode();
                    this.nodes[nodeIndex] = CritBitNode.newLeaf(key, orderIndex);
                    this.root = nodeIndex;
                    this.leafCount = 1;
                    log(`[CritBit] Inserted root node at key ${key}`, 'success');
                    return nodeIndex;
                }

                // Find insertion point
                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key === key) {
                            // Update existing
                            this.nodes[current].orderIndex = orderIndex;
                            log(`[CritBit] Updated existing key ${key}`, 'info');
                            return current;
                        }

                        // Find critical bit
                        const critBit = this.findCriticalBit(key, node.key);
                        log(`[CritBit] Critical bit found at position ${critBit}`, 'info');

                        // Create new inner node
                        const innerIndex = this.allocNode();
                        this.nodes[innerIndex] = CritBitNode.newInner(critBit);

                        // Create new leaf
                        const leafIndex = this.allocNode();
                        this.nodes[leafIndex] = CritBitNode.newLeaf(key, orderIndex);

                        // Determine sides
                        const newLeafOnRight = this.getBit(key, critBit);

                        if (newLeafOnRight) {
                            this.nodes[innerIndex].left = current;
                            this.nodes[innerIndex].right = leafIndex;
                        } else {
                            this.nodes[innerIndex].left = leafIndex;
                            this.nodes[innerIndex].right = current;
                        }

                        // Update parent pointers
                        const oldParent = node.parent;
                        this.nodes[current].parent = innerIndex;
                        this.nodes[leafIndex].parent = innerIndex;
                        this.nodes[innerIndex].parent = oldParent;

                        // Update parent's child pointer
                        if (oldParent === EMPTY) {
                            this.root = innerIndex;
                        } else {
                            const parentNode = this.nodes[oldParent];
                            if (parentNode.left === current) {
                                this.nodes[oldParent].left = innerIndex;
                            } else {
                                this.nodes[oldParent].right = innerIndex;
                            }
                        }

                        this.leafCount++;
                        log(`[CritBit] Inserted new leaf at key ${key}`, 'success');
                        return leafIndex;
                    }

                    // Inner node - traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            remove(key) {
                if (this.root === EMPTY) {
                    throw new Error('Order not found');
                }

                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key !== key) {
                            throw new Error('Order not found');
                        }

                        const orderIndex = node.orderIndex;

                        // Single node tree
                        if (node.parent === EMPTY) {
                            this.root = EMPTY;
                            this.leafCount = 0;
                            log(`[CritBit] Removed last node (key ${key})`, 'warning');
                            return orderIndex;
                        }

                        // Get parent and sibling
                        const parentIndex = node.parent;
                        const parent = this.nodes[parentIndex];
                        const siblingIndex = parent.left === current ? parent.right : parent.left;

                        // Update grandparent
                        if (parent.parent === EMPTY) {
                            this.root = siblingIndex;
                            this.nodes[siblingIndex].parent = EMPTY;
                        } else {
                            const grandparentIndex = parent.parent;
                            const grandparent = this.nodes[grandparentIndex];
                            if (grandparent.left === parentIndex) {
                                this.nodes[grandparentIndex].left = siblingIndex;
                            } else {
                                this.nodes[grandparentIndex].right = siblingIndex;
                            }
                            this.nodes[siblingIndex].parent = grandparentIndex;
                        }

                        this.leafCount--;
                        log(`[CritBit] Removed node at key ${key}`, 'warning');
                        return orderIndex;
                    }

                    // Traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            find(key) {
                if (this.root === EMPTY) return null;

                let current = this.root;
                const path = [];

                while (true) {
                    const node = this.nodes[current];
                    path.push(current);

                    if (node.isLeaf) {
                        return node.key === key ? { node, path } : null;
                    }

                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            min() {
                if (this.root === EMPTY) return null;
                return this.findMinInSubtree(this.root);
            }

            findMinInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMin = this.findMinInSubtree(node.left);
                const rightMin = this.findMinInSubtree(node.right);

                if (!leftMin) return rightMin;
                if (!rightMin) return leftMin;

                return leftMin.key < rightMin.key ? leftMin : rightMin;
            }

            max() {
                if (this.root === EMPTY) return null;
                return this.findMaxInSubtree(this.root);
            }

            findMaxInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMax = this.findMaxInSubtree(node.left);
                const rightMax = this.findMaxInSubtree(node.right);

                if (!leftMax) return rightMax;
                if (!rightMax) return leftMax;

                return leftMax.key > rightMax.key ? leftMax : rightMax;
            }
        }

        // ================= Graph Visualizer =================
        class CritBitGraphVisualizer {
            constructor(svgElement) {
                this.svg = svgElement;
                this.width = 0;
                this.height = 0;
                this.updateDimensions();
            }

            updateDimensions() {
                const container = this.svg.parentElement;
                this.width = container.clientWidth;
                this.height = container.clientHeight;
            }

            renderTree(critbitTree) {
                this.svg.innerHTML = '';
                this.updateDimensions();

                if (critbitTree.root === EMPTY) {
                    return;
                }

                // Calculate layout
                const positions = this.calculatePositions(critbitTree);

                // Draw edges first
                this.drawEdges(critbitTree, positions);

                // Draw nodes
                this.drawNodes(critbitTree, positions);
            }

            calculatePositions(tree) {
                const positions = {};
                const levels = {};

                const traverse = (nodeIndex, level, leftBound, rightBound) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const x = (leftBound + rightBound) / 2;
                    const y = 50 + level * 80;

                    positions[nodeIndex] = { x, y };

                    if (!node.isLeaf) {
                        const mid = (leftBound + rightBound) / 2;
                        traverse(node.left, level + 1, leftBound, mid);
                        traverse(node.right, level + 1, mid, rightBound);
                    }
                };

                traverse(tree.root, 0, 0, this.width);
                return positions;
            }

            drawEdges(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (!node.isLeaf) {
                        if (node.left !== EMPTY) {
                            const leftPos = positions[node.left];
                            this.drawEdge(pos.x, pos.y, leftPos.x, leftPos.y);
                            traverse(node.left);
                        }
                        if (node.right !== EMPTY) {
                            const rightPos = positions[node.right];
                            this.drawEdge(pos.x, pos.y, rightPos.x, rightPos.y);
                            traverse(node.right);
                        }
                    }
                };

                traverse(tree.root);
            }

            drawEdge(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('class', 'tree-edge');
                this.svg.appendChild(line);
            }

            drawNodes(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (node.isLeaf) {
                        this.drawLeafNode(pos.x, pos.y, node.key, nodeIndex === tree.root);
                    } else {
                        this.drawInternalNode(pos.x, pos.y, node.prefixLen, nodeIndex === tree.root);
                    }

                    if (!node.isLeaf) {
                        traverse(node.left);
                        traverse(node.right);
                    }
                };

                traverse(tree.root);
            }

            drawLeafNode(x, y, key, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - 30);
                rect.setAttribute('y', y - 15);
                rect.setAttribute('width', 60);
                rect.setAttribute('height', 30);
                rect.setAttribute('rx', 4);
                rect.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-leaf');
                g.appendChild(rect);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `$${key}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }

            drawInternalNode(x, y, prefixLen, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 20);
                circle.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-internal');
                g.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `b${prefixLen}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }
        }

        // ================= Hierarchical View =================
        class HierarchicalView {
            constructor(container) {
                this.container = container;
            }

            renderTree(critbitTree) {
                this.container.innerHTML = '';

                if (critbitTree.root === EMPTY) {
                    this.container.innerHTML = '<div class="empty-state">Tree visualization will appear here</div>';
                    return;
                }

                const html = this.renderNode(critbitTree, critbitTree.root, true);
                this.container.innerHTML = html;
            }

            renderNode(tree, nodeIndex, isRoot = false) {
                if (nodeIndex === EMPTY) return '';

                const node = tree.nodes[nodeIndex];
                const nodeClass = isRoot ? 'root' : (node.isLeaf ? 'leaf' : 'internal');

                let html = `<div class="tree-node-hier ${nodeClass}">`;

                if (node.isLeaf) {
                    html += `<div class="node-label">Leaf: $${node.key}</div>`;
                    html += `<div class="node-details">Order: #${node.orderIndex}</div>`;
                } else {
                    html += `<div class="node-label">Internal: bit ${node.prefixLen}</div>`;
                    html += `<div class="tree-children">`;
                    if (node.left !== EMPTY) {
                        html += this.renderNode(tree, node.left);
                    }
                    if (node.right !== EMPTY) {
                        html += this.renderNode(tree, node.right);
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            }
        }

        // ================= Global State =================
        let orderBook = {
            orders: [],
            last_order_id: 0
        };

        let critbitTree = new CritBitTree(100);
        let graphVisualizer = new CritBitGraphVisualizer(document.getElementById('critbitSVG'));
        let hierarchyView = new HierarchicalView(document.getElementById('treeHierarchy'));

        let totalMatches = 0;
        let totalVolume = 0;

        // ================= Logging =================
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ================= UI Updates =================
        function updateStats() {
            document.getElementById('statOrders').textContent = orderBook.orders.length;
            document.getElementById('statMatches').textContent = totalMatches;
            document.getElementById('statVolume').textContent = totalVolume;
        }

        function renderOrderBook() {
            const container = document.getElementById('orderBook');

            if (orderBook.orders.length === 0) {
                container.innerHTML = '<div class="empty-state">No orders in the book</div>';
                return;
            }

            const sortedOrders = [...orderBook.orders].sort((a, b) => {
                const priceCmp = a.price - b.price;
                if (priceCmp !== 0) return priceCmp;
                return a.created_at - b.created_at;
            });

            container.innerHTML = sortedOrders.map(order => `
                <div class="order-item ${order.side}">
                    <div class="order-meta">
                        <span><strong>#${order.order_id}</strong></span>
                        <span class="order-price ${order.side}">$${order.price}</span>
                        <button onclick="cancelOrder(${order.order_id})" class="btn-cancel">Cancel</button>
                    </div>
                    <div class="order-details">
                        ${order.side.toUpperCase()}: ${order.trader} | ${order.amount} tokens
                        ${order.order_type ? `| Type: ${order.order_type}` : ''}
                    </div>
                </div>
            `).join('');
        }

        function updateVisualization() {
            graphVisualizer.renderTree(critbitTree);
            hierarchyView.renderTree(critbitTree);
        }

        // ================= Order Placement =================
        function placeAskOrder() {
            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);

            if (!trader || !amount || !price) {
                log('[Error] All fields are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            orderBook.last_order_id++;

            const orderType = document.getElementById('order-type').value || 'limit';
            
            const order = {
                trader,
                amount,
                price,
                side: 'ask',
                order_type: orderType,
                created_at: Date.now(),
                order_id: orderBook.last_order_id
            };

            orderBook.orders.push(order);

            // Insert into CritBit tree
            try {
                critbitTree.insert(price, orderBook.last_order_id);
                log(`[Market] Ask order #${order.order_id}: ${amount} @ $${price}`, 'success');
            } catch (e) {
                log(`[Error] ${e.message}`, 'error');
            }

            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        function placeBidOrder() {
            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);
            const orderType = document.getElementById('order-type').value || 'limit';

            if (!trader || !amount || !price) {
                log('[Error] All fields are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            log(`[${orderType.toUpperCase()}] Bid order: ${amount} @ max $${price}`, 'info');

            // Find matching asks
            const matchingAsks = orderBook.orders
                .filter(order => order.side === 'ask' && order.price <= price)
                .sort((a, b) => {
                    const priceCmp = a.price - b.price;
                    if (priceCmp !== 0) return priceCmp;
                    return a.created_at - b.created_at;
                });

            // Check total available for FOK
            const totalAvailable = matchingAsks.reduce((sum, ask) => sum + ask.amount, 0);

            // Execute based on order type (simplified: Limit and FOK only)
            switch(orderType) {
                case 'limit':
                    executeLimitBid(trader, amount, price, matchingAsks);
                    break;
                    
                case 'fok':
                    executeFOKBid(trader, amount, price, matchingAsks, totalAvailable);
                    break;
                    
                default:
                    executeLimitBid(trader, amount, price, matchingAsks);
            }

            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        function executeLimitBid(trader, amount, price, matchingAsks) {
            // 1:1 MATCHING - Only match against FIRST compatible ask
            if (matchingAsks.length === 0) {
                log('[Limit] No matching orders found', 'error');
                return;
            }

            // Match against FIRST ask only (1:1 buyer:seller)
            const askOrder = matchingAsks[0];
            const fillAmount = Math.min(amount, askOrder.amount);
            
            log(`[Match] 1:1 - ${fillAmount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += fillAmount;

            // Update ask order
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                orderBook.orders[orderIndex].amount -= fillAmount;
                if (orderBook.orders[orderIndex].amount <= 0) {
                    critbitTree.remove(askOrder.price);
                    orderBook.orders.splice(orderIndex, 1);
                    log(`[CritBit] Removed ask order #${askOrder.order_id}`, 'info');
                }
            }

            const remaining = amount - fillAmount;
            log(`[Limit] Matched ${fillAmount}/${amount} tokens (1:1 single seller)`, 'success');

            // If remaining, add as resting limit order
            if (remaining > 0) {
                orderBook.last_order_id++;
                const restingBid = {
                    trader,
                    amount: remaining,
                    price,
                    side: 'bid',
                    order_type: 'limit',
                    created_at: Date.now(),
                    order_id: orderBook.last_order_id
                };
                orderBook.orders.push(restingBid);
                critbitTree.insert(price, orderBook.last_order_id);
                log(`[Limit] Resting bid added: ${remaining} @ $${price}`, 'info');
            }
        }

        function executeFOKBid(trader, amount, price, matchingAsks, totalAvailable) {
            // FOK: Must match EXACTLY with single ask (1:1 + exact amount)
            if (matchingAsks.length === 0) {
                log('[FOK] No matching orders - REJECTED', 'error');
                return;
            }

            // Check if FIRST ask can fill the EXACT amount
            const askOrder = matchingAsks[0];
            
            if (askOrder.amount !== amount) {
                log('[FOK] Cannot fill exactly - REJECTED', 'error');
                log(`[FOK] Need exactly ${amount}, but first ask has ${askOrder.amount}`, 'error');
                return;
            }

            // Perfect match - fill completely
            log(`[Match] 1:1 FOK - ${amount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += amount;

            // Remove ask order completely
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                critbitTree.remove(askOrder.price);
                orderBook.orders.splice(orderIndex, 1);
            }

            log(`[FOK] Filled ${amount}/${amount} tokens exactly (1:1 perfect match)`, 'success');
        }

        function cancelOrder(orderId) {
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === orderId);
            if (orderIndex === -1) {
                log(`[Error] Order #${orderId} not found`, 'error');
                return;
            }
            
            const order = orderBook.orders[orderIndex];
            
            // Remove from CritBit tree if this was the last order at this price
            const ordersAtPrice = orderBook.orders.filter(o => o.price === order.price && o.order_id !== orderId);
            if (ordersAtPrice.length === 0) {
                try {
                    critbitTree.remove(order.price);
                    log(`[CritBit] Removed price level ${order.price} from tree`, 'info');
                } catch (e) {
                    log(`[CritBit] ${e.message}`, 'warning');
                }
            }
            
            // Remove from order book
            orderBook.orders.splice(orderIndex, 1);
            
            log(`[Cancel] Order #${orderId} cancelled: ${order.trader}, ${order.amount} @ $${order.price}`, 'warning');
            
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        function clearAll() {
            orderBook.orders = [];
            orderBook.last_order_id = 0;
            totalMatches = 0;
            totalVolume = 0;
            critbitTree = new CritBitTree(100);
            log('[System] All orders cleared', 'warning');
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        // Initialize
        updateStats();
        window.addEventListener('resize', () => updateVisualization());
    </script>

    <!-- Solana Web3.js CDN -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    
    <!-- Phantom Wallet Integration -->
    <script>
        // Solana configuration
        const DEVNET_RPC = 'https://api.devnet.solana.com';
        const connection = new solanaWeb3.Connection(DEVNET_RPC, 'confirmed');
        
        // Deployed program ID
        const MARKET_PROGRAM_ID = 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB';
        
        let phantomWallet = null;
        let connectedPubkey = null;
        
        async function connectPhantomWallet() {
            try {
                // Check if Phantom is installed
                if (!window.solana || !window.solana.isPhantom) {
                    alert('Phantom wallet not found!\\n\\nPlease install Phantom from phantom.app');
                    window.open('https://phantom.app/', '_blank');
                    return false;
                }
                
                log('[Wallet] Phantom detected, connecting...', 'info');
                
                // Request connection
                const resp = await window.solana.connect();
                connectedPubkey = resp.publicKey.toString();
                phantomWallet = window.solana;
                
                log('[Wallet] ✅ Connected: ' + connectedPubkey.slice(0, 8) + '...' + connectedPubkey.slice(-8), 'success');
                
                // Update button UI
                const btn = document.getElementById('phantomConnectBtn');
                if (btn) {
                    btn.textContent = '✅ Connected: ' + connectedPubkey.slice(0, 4) + '...' + connectedPubkey.slice(-4);
                    btn.style.background = 'linear-gradient(135deg, #00ff88, #00aa55)';
                    btn.onclick = disconnectPhantom;
                }
                
                // Get and display balance
                const balance = await connection.getBalance(new solanaWeb3.PublicKey(connectedPubkey));
                const solBalance = (balance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                log('[Wallet] Balance: ' + solBalance + ' SOL', 'info');
                log('[Network] Connected to Devnet', 'info');
                log('[Program] Market ID: ' + MARKET_PROGRAM_ID.slice(0, 8) + '...', 'info');
                
                return true;
            } catch (err) {
                log('[Wallet] ❌ Connection failed: ' + err.message, 'error');
                return false;
            }
        }
        
        async function disconnectPhantom() {
            if (phantomWallet) {
                try {
                    await phantomWallet.disconnect();
                    connectedPubkey = null;
                    phantomWallet = null;
                    
                    const btn = document.getElementById('phantomConnectBtn');
                    if (btn) {
                        btn.textContent = '🔗 Connect Phantom Wallet';
                        btn.style.background = 'linear-gradient(135deg, #ab9ff2 0%, #6f5cc6 100%)';
                        btn.onclick = connectPhantomWallet;
                    }
                    
                    log('[Wallet] Disconnected', 'info');
                } catch (err) {
                    log('[Wallet] Error disconnecting: ' + err.message, 'error');
                }
            }
        }
        
        // Auto-detect Phantom on page load
        window.addEventListener('load', async () => {
            if (window.solana) {
                log('[Wallet] Phantom extension detected', 'success');
                // Auto-connect if previously authorized
                if (window.solana.isConnected) {
                    await connectPhantomWallet();
                }
            } else {
                log('[Wallet] Phantom not installed. Click button to install.', 'warning');
            }
        });
        
        // Handle account changes
        if (window.solana) {
            window.solana.on('accountChanged', (publicKey) => {
                if (publicKey) {
                    connectedPubkey = publicKey.toString();
                    log('[Wallet] Account switched to ' + connectedPubkey.slice(0, 8) + '...', 'info');
                    connectPhantomWallet();
                } else {
                    disconnectPhantom();
                }
            });
            
            window.solana.on('disconnect', () => {
                log('[Wallet] Phantom disconnected', 'warning');
                disconnectPhantom();
            });
        }
        
        console.log('✅ 2k2Peer Phantom Integration Ready');
        console.log('📍 Market Program:', MARKET_PROGRAM_ID);
        console.log('🌐 Network: Devnet (' + DEVNET_RPC + ')');
        
        // ============================================================
        // PDA (Program Derived Address) Explanation
        // ============================================================
        // PDAs are deterministic addresses derived from:
        // - Program ID
        // - Seeds (like "market", "order_book", token mint)
        // - Bump seed (ensures address is off ed25519 curve)
        //
        // PDAs let programs "own" accounts without private keys
        // Used for: Market state, Order Book, Token Escrow
        // ============================================================
        
        // Token mint (set this after creating test token on devnet)
        const TOKEN_MINT = null;
        
        // Derive PDA helper
        async function derivePDA(seeds, programId) {
            return await solanaWeb3.PublicKey.findProgramAddress(
                seeds,
                new solanaWeb3.PublicKey(programId)
            );
        }
        
        // Get all Market program PDAs
        async function getMarketPDAs(tokenMint) {
            const tokenPubkey = new solanaWeb3.PublicKey(tokenMint);
            const programId = MARKET_PROGRAM_ID;
            
            const [market] = await derivePDA(
                [Buffer.from('market'), tokenPubkey.toBuffer()],
                programId
            );
            const [orderBook] = await derivePDA(
                [Buffer.from('order_book'), tokenPubkey.toBuffer()],
                programId
            );
            const [escrowVault] = await derivePDA(
                [Buffer.from('escrow_vault'), tokenPubkey.toBuffer()],
                programId
            );
            const [escrowAuthority] = await derivePDA(
                [Buffer.from('escrow_authority'), tokenPubkey.toBuffer()],
                programId
            );
            
            log('[PDA] Market: ' + market.toString().slice(0, 8) + '...', 'info');
            log('[PDA] OrderBook: ' + orderBook.toString().slice(0, 8) + '...', 'info');
            
            return { market, orderBook, escrowVault, escrowAuthority };
        }
        
        console.log('[2k2Peer] PDA functions ready');
    </script>
</body>
</html>
