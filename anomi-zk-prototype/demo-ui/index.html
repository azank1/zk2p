<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2k2Peer - DEX Interface</title>
    
    <!-- Buffer Polyfill - MUST load first before any Solana libraries -->
    <script>
        // Create a complete Buffer polyfill inline
        // NOT wrapped in IIFE to ensure global access
        (function() {
            'use strict';
            function createBufferPolyfill() {
                function BufferImpl(arg, encoding) {
                    if (!(this instanceof BufferImpl)) {
                        return new BufferImpl(arg, encoding);
                    }
                    
                    if (typeof arg === 'number') {
                        this.data = new Uint8Array(arg);
                    } else if (typeof arg === 'string') {
                        const encoder = new TextEncoder();
                        this.data = encoder.encode(arg);
                    } else if (Array.isArray(arg)) {
                        this.data = new Uint8Array(arg);
                    } else if (arg instanceof Uint8Array) {
                        this.data = new Uint8Array(arg);
                    } else {
                        this.data = new Uint8Array(0);
                    }
                    
                    this.length = this.data.length;
                    this.buffer = this.data.buffer;
                    return this;
                }
                
                // Static methods
                BufferImpl.from = function(data, encoding) {
                    if (Array.isArray(data)) {
                        return new BufferImpl(new Uint8Array(data));
                    } else if (typeof data === 'string') {
                        if (encoding === 'hex') {
                            const bytes = [];
                            for (let i = 0; i < data.length; i += 2) {
                                bytes.push(parseInt(data.substr(i, 2), 16));
                            }
                            return new BufferImpl(new Uint8Array(bytes));
                        }
                        const encoder = new TextEncoder();
                        return new BufferImpl(encoder.encode(data));
                    } else if (data instanceof Uint8Array || (data && data.buffer instanceof ArrayBuffer)) {
                        // Handle Uint8Array (including from PublicKey.toBuffer())
                        return new BufferImpl(data);
                    } else if (data && typeof data.length === 'number') {
                        // Handle array-like objects
                        return new BufferImpl(new Uint8Array(data));
                    }
                    // Fallback: try to convert
                    try {
                        return new BufferImpl(new Uint8Array(data));
                    } catch (e) {
                        console.error('[Buffer] Failed to convert data:', data, e);
                        return new BufferImpl(new Uint8Array(0));
                    }
                };
                
                BufferImpl.alloc = function(size, fill) {
                    const buf = new BufferImpl(new Uint8Array(size));
                    if (fill !== undefined) {
                        buf.data.fill(fill);
                    }
                    return buf;
                };
                
                BufferImpl.concat = function(arrays) {
                    const totalLength = arrays.reduce((sum, arr) => {
                        const len = arr instanceof BufferImpl ? arr.length : arr.length;
                        return sum + len;
                    }, 0);
                    const result = new Uint8Array(totalLength);
                    let offset = 0;
                    for (const arr of arrays) {
                        const data = arr instanceof BufferImpl ? arr.data : arr;
                        result.set(data, offset);
                        offset += data.length;
                    }
                    return new BufferImpl(result);
                };
                
                // Instance methods
                BufferImpl.prototype.writeBigUInt64LE = function(value, offset) {
                    offset = offset || 0;
                    const view = new DataView(this.buffer, offset);
                    view.setBigUint64(0, BigInt(value), true); // little-endian
                };
                
                BufferImpl.prototype.writeUInt8 = function(value, offset) {
                    this.data[offset || 0] = value;
                };
                
                BufferImpl.prototype.writeUInt32LE = function(value, offset) {
                    offset = offset || 0;
                    const view = new DataView(this.buffer, offset);
                    view.setUint32(0, value, true); // little-endian
                };
                
                BufferImpl.prototype.copy = function(target, targetStart, sourceStart, sourceEnd) {
                    targetStart = targetStart || 0;
                    sourceStart = sourceStart || 0;
                    sourceEnd = sourceEnd || this.length;
                    const sourceData = this.data.subarray(sourceStart, sourceEnd);
                    if (target instanceof BufferImpl) {
                        target.data.set(sourceData, targetStart);
                    } else if (target instanceof Uint8Array) {
                        target.set(sourceData, targetStart);
                    }
                };
                
                // Make it work with PublicKey.toBuffer()
                BufferImpl.prototype.slice = function(start, end) {
                    return new BufferImpl(this.data.slice(start, end));
                };
                
                return BufferImpl;
            }
            
            // Install immediately - set Buffer globally BEFORE wrapping
            const BufferPolyfill = createBufferPolyfill();
            
            // CRITICAL: Set Buffer on window FIRST, before any other code runs
            if (typeof window !== 'undefined') {
                window.Buffer = BufferPolyfill;
            }
            
            // Set Buffer in all possible global locations
            if (typeof global === 'undefined') {
                if (typeof window !== 'undefined') {
                    window.global = window;
                }
            }
            if (typeof global !== 'undefined') {
                global.Buffer = BufferPolyfill;
            }
            
            // Also set it on globalThis
            if (typeof globalThis !== 'undefined') {
                globalThis.Buffer = BufferPolyfill;
            }
            
            // CRITICAL: Also set it as a direct global variable (not just window.Buffer)
            // This makes it accessible as just "Buffer" without window prefix
            try {
                // Use eval to set in global scope (only way to set true global in strict mode)
                (function() {
                    // Non-strict mode wrapper to set global
                    var root = (function() { return this; })();
                    if (root) {
                        root.Buffer = BufferPolyfill;
                    }
                })();
            } catch (e) {
                // Fallback: just ensure window.Buffer is set
                console.warn('[Buffer] Could not set Buffer as direct global:', e);
            }
            
            console.log('[Buffer] Inline polyfill loaded synchronously');
            console.log('[Buffer] window.Buffer type:', typeof window.Buffer);
            console.log('[Buffer] window.Buffer.from:', typeof window.Buffer !== 'undefined' ? typeof window.Buffer.from : 'undefined');
            console.log('[Buffer] Direct Buffer check:', typeof Buffer);
            console.log('[Buffer] global.Buffer:', typeof global !== 'undefined' ? typeof global.Buffer : 'global undefined');
            
            // Dispatch bufferReady event immediately
            if (typeof window !== 'undefined' && window.dispatchEvent) {
                try {
                    window.dispatchEvent(new Event('bufferReady'));
                    console.log('[Buffer] bufferReady event dispatched');
                } catch (e) {
                    console.warn('[Buffer] Could not dispatch bufferReady event:', e);
                    // Fallback: trigger after a tiny delay
                    setTimeout(function() {
                        if (window.dispatchEvent) {
                            window.dispatchEvent(new Event('bufferReady'));
                        }
                    }, 10);
                }
            }
            
            // Try to load full buffer polyfill in background for better compatibility
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.js';
            script.async = true;
            script.onload = function() {
                if (typeof buffer !== 'undefined' && buffer.Buffer) {
                    window.Buffer = buffer.Buffer;
                    global.Buffer = buffer.Buffer;
                    console.log('[Buffer] Full polyfill loaded, replacing inline version');
                    window.dispatchEvent(new Event('bufferReady'));
                }
            };
            script.onerror = function() {
                console.warn('[Buffer] Failed to load full polyfill from CDN, using inline version');
            };
            document.head.appendChild(script);
        })();
        
        // CRITICAL: Ensure Buffer is accessible globally after IIFE
        // This is a fallback to ensure Buffer is truly global
        if (typeof window !== 'undefined' && window.Buffer) {
            // Make Buffer available without window prefix by creating a reference
            // Note: In strict mode, we can't create true globals, but window.Buffer should work
            console.log('[Buffer] Post-IIFE check - window.Buffer available:', typeof window.Buffer !== 'undefined');
        } else {
            console.error('[Buffer] CRITICAL: Buffer not found on window after initialization!');
        }
    </script>
    
    <!-- Ensure Buffer is accessible - create a global reference -->
    <script>
        // This script runs immediately after Buffer polyfill
        // It ensures Buffer is accessible as a global variable
        if (typeof window !== 'undefined' && window.Buffer) {
            // In browser context, window.Buffer should be accessible as Buffer
            // But to be safe, we'll also check and log
            console.log('[Buffer] Global check script - window.Buffer:', typeof window.Buffer);
            console.log('[Buffer] Global check script - Buffer (direct):', typeof Buffer);
            
            // Verify Buffer methods are available
            if (window.Buffer && typeof window.Buffer.from === 'function') {
                console.log('[Buffer] ✅ Buffer polyfill is properly initialized');
            } else {
                console.error('[Buffer] ❌ Buffer polyfill missing methods!');
            }
        } else {
            console.error('[Buffer] ❌ Buffer not found on window object!');
        }
    </script>
    
    <!-- Configuration Loader - Load before other scripts -->
    <script src="config-loader.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Glassmorphism Effects */
        .glass-panel {
            background: rgba(26, 26, 26, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.1);
        }

        .neon-glow {
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5),
                        0 0 20px rgba(0, 255, 136, 0.3),
                        0 0 30px rgba(0, 255, 136, 0.2);
        }

        .neon-glow-blue {
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.5),
                        0 0 20px rgba(0, 170, 255, 0.3);
        }

        .neon-glow-purple {
            box-shadow: 0 0 10px rgba(170, 0, 255, 0.5),
                        0 0 20px rgba(170, 0, 255, 0.3);
        }

        /* Animations */
        @keyframes node-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes edge-draw {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes glow-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        /* Layout */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 20px;
            min-height: 100vh;
        }

        .panel {
            padding: 20px;
            overflow: hidden;
            animation: fade-in 0.5s ease;
        }

        .panel h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Order Entry Panel */
        .order-entry {
            grid-row: 1 / 3;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-ask {
            background: linear-gradient(135deg, #ff4444 0%, #cc3333 100%);
            color: #fff;
        }

        .btn-ask:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .btn-bid {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
        }

        .btn-bid:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .btn-clear {
            background: rgba(102, 102, 102, 0.5);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-clear:hover {
            background: rgba(136, 136, 136, 0.5);
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff 0%, #0088cc 100%);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-cancel {
            background: #ff4444;
            color: white;
            border: none;
            padding: 3px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 8px;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background: #ff6666;
            transform: scale(1.05);
        }

        .btn-scenario {
            background: rgba(0, 170, 255, 0.3);
            color: white;
            border: 1px solid rgba(0, 170, 255, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 8px;
            width: 100%;
            transition: all 0.2s;
        }

        .btn-scenario:hover {
            background: rgba(0, 170, 255, 0.5);
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.4);
        }

        .btn-payment {
            background: linear-gradient(135deg, #ffaa00 0%, #ff8800 100%);
            color: #000;
            font-weight: bold;
        }

        .btn-payment:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }

        .btn-payment:disabled {
            background: rgba(102, 102, 102, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        /* Payment Status Section */
        .payment-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 6px;
            display: none;
        }

        .payment-section h4 {
            color: #ffaa00;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .payment-status {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
        }

        .settlement-timer {
            padding: 15px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            text-align: center;
            margin-top: 10px;
        }

        .countdown {
            font-size: 2em;
            color: #00ff88;
            font-weight: bold;
            margin: 10px 0;
        }

        .wallet-role {
            background: rgba(0, 170, 255, 0.2);
            border: 1px solid rgba(0, 170, 255, 0.4);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            color: #00aaff;
        }

        /* Toggle Switch Styling */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(102, 102, 102, 0.5);
            border-radius: 13px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            border-color: #00ff88;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 0.7em;
            color: #999;
            margin-top: 3px;
            text-transform: uppercase;
        }

        /* Order Book */
        .order-book-panel {
            grid-row: 1 / 2;
        }

        .order-book {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .order-item {
            background: rgba(26, 26, 26, 0.8);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #00ff88;
            font-size: 0.85em;
            animation: fade-in 0.3s ease;
        }

        .order-item.ask {
            border-left-color: #ff4444;
        }

        .order-item.matched {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            animation: node-pulse 0.8s ease;
        }

        .order-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .order-price {
            color: #00ff88;
            font-weight: bold;
        }

        .order-price.ask {
            color: #ff4444;
        }

        .order-details {
            color: #999;
            font-size: 0.9em;
        }

        /* CritBit Graph */
        .critbit-graph-panel {
            grid-row: 1 / 2;
        }

        .svg-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            height: 400px;
            overflow: hidden;
            position: relative;
        }

        #critbitSVG {
            width: 100%;
            height: 100%;
        }

        .tree-node-svg {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tree-node-svg:hover {
            filter: brightness(1.3);
        }

        .tree-node-root {
            fill: #00ff88;
        }

        .tree-node-internal {
            fill: #aa00ff;
        }

        .tree-node-leaf {
            fill: #00aaff;
        }

        .tree-edge {
            stroke: rgba(0, 255, 136, 0.5);
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 1000;
            stroke-dashoffset: 0;
        }

        .tree-edge.animated {
            animation: edge-draw 0.6s ease;
        }

        .tree-label {
            fill: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            text-anchor: middle;
        }

        /* Hierarchical Tree */
        .hierarchy-panel {
            grid-row: 1 / 2;
        }

        .tree-hierarchy {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .tree-node-hier {
            margin: 5px 0;
            padding: 8px;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 3px;
            border-left: 3px solid #00ff88;
        }

        .tree-node-hier.root {
            border-left-color: #00ff88;
        }

        .tree-node-hier.internal {
            border-left-color: #aa00ff;
        }

        .tree-node-hier.leaf {
            border-left-color: #00aaff;
        }

        .tree-node-hier .node-label {
            color: #00ff88;
            font-weight: bold;
        }

        .tree-node-hier .node-details {
            color: #999;
            font-size: 0.9em;
            margin-top: 3px;
        }

        .tree-children {
            margin-left: 20px;
            margin-top: 5px;
        }

        /* Transaction Log */
        .log-panel {
            grid-column: 1 / -1;
            grid-row: 2 / 3;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            animation: fade-in 0.3s ease;
        }

        .log-entry.success {
            color: #00ff88;
        }

        .log-entry.info {
            color: #00aaff;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.warning {
            color: #ffaa00;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 300px 1fr 1fr;
                grid-template-rows: auto auto 1fr;
            }
            .hierarchy-panel {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
            }
            .log-panel {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto;
            }
            .order-entry {
                grid-row: 1 / 2;
                grid-column: 1 / 2;
            }
            .order-book-panel {
                grid-row: 1 / 2;
                grid-column: 2 / 3;
            }
            .critbit-graph-panel {
                grid-row: 2 / 3;
                grid-column: 1 / 3;
            }
            .hierarchy-panel {
                grid-row: 3 / 4;
                grid-column: 1 / 3;
            }
            .log-panel {
                grid-row: 4 / 5;
                grid-column: 1 / 3;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Order Entry Panel -->
        <div class="panel glass-panel order-entry">
            <h3>Place Order</h3>
            
            <!-- Phantom Wallet Connection -->
            <button id="phantomConnectBtn" class="btn" onclick="connectPhantomWallet()" style="background: linear-gradient(135deg, #ab9ff2 0%, #6f5cc6 100%); margin-bottom: 15px;">
                Connect Phantom Wallet
            </button>
            
            <!-- Wallet Role Indicator -->
            <div id="walletRole" class="wallet-role" style="display:none;">
                Role: <span id="walletRoleText">Unknown</span>
            </div>
            
            <!-- Wallet Balance Display -->
            <div id="walletBalance" class="wallet-role" style="display:none;">
                <div>SOL: <span id="solBalance">0</span></div>
                <div>Tokens: <span id="tokenBalance">0</span></div>
            </div>
            
            <!-- ZK Fiat Mode Toggle -->
            <div class="form-group" style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                    <span>P2P Fiat Settlement (Stub ZK)</span>
                    <input type="checkbox" id="zkFiatModeToggle" checked style="display: none;">
                    <div class="toggle-switch" id="toggleSwitch">
                        <div class="toggle-slider"></div>
                    </div>
                </label>
                <small style="color: #999; font-size: 0.75em; margin-top: 5px; display: block;">
                    When enabled, matched orders require fiat payment confirmation
                </small>
            </div>
            
            <!-- Token Mint Configuration -->
            <div class="form-group">
                <label>Token Mint Address</label>
                <input type="text" id="tokenMint" placeholder="Token Mint Address (leave blank for default)" value="">
            </div>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="statOrders">0</div>
                    <div class="stat-label">Orders</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statMatches">0</div>
                    <div class="stat-label">Matches</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statVolume">0</div>
                    <div class="stat-label">Volume</div>
                </div>
            </div>

            <div class="form-group">
                <label>Trader</label>
                <input type="text" id="trader" placeholder="Trader Name" value="Alice">
            </div>
            
            <div class="form-group">
                <label>Amount</label>
                <input type="number" id="amount" placeholder="100" value="100">
            </div>
            
            <div class="form-group">
                <label>Price</label>
                <input type="number" id="price" placeholder="50" value="50">
            </div>
            
            <div class="form-group">
                <label>Payment Method</label>
                <input type="text" id="payment" placeholder="PayPal" value="PayPal">
            </div>
            
            <div class="form-group">
                <label>Order Type</label>
                <select id="order-type" class="input">
                    <option value="limit">Limit Order</option>
                    <option value="fok">FOK (Fill-or-Kill)</option>
                </select>
            </div>

            <button class="btn btn-ask" onclick="placeAskOrder()">Place Ask</button>
            <button class="btn btn-bid" onclick="placeBidOrder()">Place Bid</button>
            <button class="btn btn-scenario" onclick="matchOrdersOnChain()">Match Orders (On-Chain)</button>
            <button class="btn btn-clear" onclick="clearAll()">Clear All</button>
            
            <!-- P2P Payment Status Section -->
            <div id="paymentSection" class="payment-section">
                <h4>P2P Payment Status</h4>
                <div id="paymentStatus" class="payment-status">Waiting for match...</div>
                <button id="markPaidBtn" class="btn btn-payment" onclick="markPaymentMade()" style="display:none;">
                    Mark Payment Made
                </button>
                <div id="settlementTimer" class="settlement-timer" style="display:none;">
                    Verifying payment (stub ZK)...<br>
                    <div class="countdown"><span id="countdown">10</span>s</div>
                    <small>In production: ZK proof verification would happen here</small>
                </div>
            </div>
        </div>

        <!-- Order Book Panel -->
        <div class="panel glass-panel order-book-panel">
            <h3>Order Book</h3>
            <button id="fetchOrderBookBtn" class="btn btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="if(window.fetchOrderBookState){window.fetchOrderBookState();}else{log('[OrderBook] Function not ready', 'error');}">
                Fetch Order Book
            </button>
            <div class="order-book" id="orderBook">
                <div class="empty-state">No orders in the book</div>
            </div>
        </div>

        <!-- CritBit Graph Panel -->
        <div class="panel glass-panel critbit-graph-panel">
            <h3>CritBit Tree Graph</h3>
            <div class="svg-container">
                <svg id="critbitSVG"></svg>
            </div>
        </div>

        <!-- Hierarchical Tree Panel -->
        <div class="panel glass-panel hierarchy-panel">
            <h3>Tree Structure</h3>
            <div class="tree-hierarchy" id="treeHierarchy">
                <div class="empty-state">Tree visualization will appear here</div>
            </div>
        </div>

        <!-- Transaction Log Panel -->
        <div class="panel glass-panel log-panel">
            <h3>Transaction Log</h3>
            <div class="log-container" id="logContainer">
                <div class="log-entry info">[System] Initialized. Ready to process orders.</div>
            </div>
        </div>
    </div>

    <script>
        // ================= CritBit Tree Implementation =================
        const EMPTY = 0xFFFFFFFF;

        class CritBitNode {
            constructor(isLeaf = false) {
                this.key = 0;
                this.orderIndex = 0;
                this.parent = EMPTY;
                this.left = EMPTY;
                this.right = EMPTY;
                this.prefixLen = 0;
                this.isLeaf = isLeaf;
            }

            static newLeaf(key, orderIndex) {
                const node = new CritBitNode(true);
                node.key = key;
                node.orderIndex = orderIndex;
                return node;
            }

            static newInner(prefixLen) {
                const node = new CritBitNode(false);
                node.prefixLen = prefixLen;
                return node;
            }
        }

        class CritBitTree {
            constructor(capacity = 100) {
                this.nodes = [];
                for (let i = 0; i < capacity; i++) {
                    this.nodes.push(new CritBitNode());
                }
                this.root = EMPTY;
                this.leafCount = 0;
                this.freeList = 0;
            }

            findCriticalBit(key1, key2) {
                const xor = key1 ^ key2;
                if (xor === 0) return 64;
                return 63 - Math.clz32(xor);
            }

            getBit(key, bitPos) {
                if (bitPos >= 64) return false;
                return ((key >> bitPos) & 1) === 1;
            }

            allocNode() {
                if (this.freeList >= this.nodes.length) {
                    throw new Error('OrderBook full');
                }
                return this.freeList++;
            }

            insert(key, orderIndex) {
                // Empty tree case
                if (this.root === EMPTY) {
                    const nodeIndex = this.allocNode();
                    this.nodes[nodeIndex] = CritBitNode.newLeaf(key, orderIndex);
                    this.root = nodeIndex;
                    this.leafCount = 1;
                    log(`[CritBit] Inserted root node at key ${key}`, 'success');
                    return nodeIndex;
                }

                // Find insertion point
                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key === key) {
                            // Update existing
                            this.nodes[current].orderIndex = orderIndex;
                            log(`[CritBit] Updated existing key ${key}`, 'info');
                            return current;
                        }

                        // Find critical bit
                        const critBit = this.findCriticalBit(key, node.key);
                        log(`[CritBit] Critical bit found at position ${critBit}`, 'info');

                        // Create new inner node
                        const innerIndex = this.allocNode();
                        this.nodes[innerIndex] = CritBitNode.newInner(critBit);

                        // Create new leaf
                        const leafIndex = this.allocNode();
                        this.nodes[leafIndex] = CritBitNode.newLeaf(key, orderIndex);

                        // Determine sides
                        const newLeafOnRight = this.getBit(key, critBit);

                        if (newLeafOnRight) {
                            this.nodes[innerIndex].left = current;
                            this.nodes[innerIndex].right = leafIndex;
                        } else {
                            this.nodes[innerIndex].left = leafIndex;
                            this.nodes[innerIndex].right = current;
                        }

                        // Update parent pointers
                        const oldParent = node.parent;
                        this.nodes[current].parent = innerIndex;
                        this.nodes[leafIndex].parent = innerIndex;
                        this.nodes[innerIndex].parent = oldParent;

                        // Update parent's child pointer
                        if (oldParent === EMPTY) {
                            this.root = innerIndex;
                        } else {
                            const parentNode = this.nodes[oldParent];
                            if (parentNode.left === current) {
                                this.nodes[oldParent].left = innerIndex;
                            } else {
                                this.nodes[oldParent].right = innerIndex;
                            }
                        }

                        this.leafCount++;
                        log(`[CritBit] Inserted new leaf at key ${key}`, 'success');
                        return leafIndex;
                    }

                    // Inner node - traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            remove(key) {
                if (this.root === EMPTY) {
                    throw new Error('Order not found');
                }

                let current = this.root;
                while (true) {
                    const node = this.nodes[current];

                    if (node.isLeaf) {
                        if (node.key !== key) {
                            throw new Error('Order not found');
                        }

                        const orderIndex = node.orderIndex;

                        // Single node tree
                        if (node.parent === EMPTY) {
                            this.root = EMPTY;
                            this.leafCount = 0;
                            log(`[CritBit] Removed last node (key ${key})`, 'warning');
                            return orderIndex;
                        }

                        // Get parent and sibling
                        const parentIndex = node.parent;
                        const parent = this.nodes[parentIndex];
                        const siblingIndex = parent.left === current ? parent.right : parent.left;

                        // Update grandparent
                        if (parent.parent === EMPTY) {
                            this.root = siblingIndex;
                            this.nodes[siblingIndex].parent = EMPTY;
                        } else {
                            const grandparentIndex = parent.parent;
                            const grandparent = this.nodes[grandparentIndex];
                            if (grandparent.left === parentIndex) {
                                this.nodes[grandparentIndex].left = siblingIndex;
                            } else {
                                this.nodes[grandparentIndex].right = siblingIndex;
                            }
                            this.nodes[siblingIndex].parent = grandparentIndex;
                        }

                        this.leafCount--;
                        log(`[CritBit] Removed node at key ${key}`, 'warning');
                        return orderIndex;
                    }

                    // Traverse down
                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            find(key) {
                if (this.root === EMPTY) return null;

                let current = this.root;
                const path = [];

                while (true) {
                    const node = this.nodes[current];
                    path.push(current);

                    if (node.isLeaf) {
                        return node.key === key ? { node, path } : null;
                    }

                    if (this.getBit(key, node.prefixLen)) {
                        current = node.right;
                    } else {
                        current = node.left;
                    }
                }
            }

            min() {
                if (this.root === EMPTY) return null;
                return this.findMinInSubtree(this.root);
            }

            findMinInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMin = this.findMinInSubtree(node.left);
                const rightMin = this.findMinInSubtree(node.right);

                if (!leftMin) return rightMin;
                if (!rightMin) return leftMin;

                return leftMin.key < rightMin.key ? leftMin : rightMin;
            }

            max() {
                if (this.root === EMPTY) return null;
                return this.findMaxInSubtree(this.root);
            }

            findMaxInSubtree(nodeIndex) {
                if (nodeIndex === EMPTY) return null;

                const node = this.nodes[nodeIndex];

                if (node.isLeaf) {
                    return { key: node.key, nodeIndex };
                }

                // Recursively check both children
                const leftMax = this.findMaxInSubtree(node.left);
                const rightMax = this.findMaxInSubtree(node.right);

                if (!leftMax) return rightMax;
                if (!rightMax) return leftMax;

                return leftMax.key > rightMax.key ? leftMax : rightMax;
            }
        }

        // ================= Graph Visualizer =================
        class CritBitGraphVisualizer {
            constructor(svgElement) {
                this.svg = svgElement;
                this.width = 0;
                this.height = 0;
                this.updateDimensions();
            }

            updateDimensions() {
                const container = this.svg.parentElement;
                this.width = container.clientWidth;
                this.height = container.clientHeight;
            }

            renderTree(critbitTree) {
                this.svg.innerHTML = '';
                this.updateDimensions();

                if (critbitTree.root === EMPTY) {
                    return;
                }

                // Calculate layout
                const positions = this.calculatePositions(critbitTree);

                // Draw edges first
                this.drawEdges(critbitTree, positions);

                // Draw nodes
                this.drawNodes(critbitTree, positions);
            }

            calculatePositions(tree) {
                const positions = {};
                const levels = {};

                const traverse = (nodeIndex, level, leftBound, rightBound) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const x = (leftBound + rightBound) / 2;
                    const y = 50 + level * 80;

                    positions[nodeIndex] = { x, y };

                    if (!node.isLeaf) {
                        const mid = (leftBound + rightBound) / 2;
                        traverse(node.left, level + 1, leftBound, mid);
                        traverse(node.right, level + 1, mid, rightBound);
                    }
                };

                traverse(tree.root, 0, 0, this.width);
                return positions;
            }

            drawEdges(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (!node.isLeaf) {
                        if (node.left !== EMPTY) {
                            const leftPos = positions[node.left];
                            this.drawEdge(pos.x, pos.y, leftPos.x, leftPos.y);
                            traverse(node.left);
                        }
                        if (node.right !== EMPTY) {
                            const rightPos = positions[node.right];
                            this.drawEdge(pos.x, pos.y, rightPos.x, rightPos.y);
                            traverse(node.right);
                        }
                    }
                };

                traverse(tree.root);
            }

            drawEdge(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('class', 'tree-edge');
                this.svg.appendChild(line);
            }

            drawNodes(tree, positions) {
                const traverse = (nodeIndex) => {
                    if (nodeIndex === EMPTY) return;

                    const node = tree.nodes[nodeIndex];
                    const pos = positions[nodeIndex];

                    if (node.isLeaf) {
                        this.drawLeafNode(pos.x, pos.y, node.key, nodeIndex === tree.root);
                    } else {
                        this.drawInternalNode(pos.x, pos.y, node.prefixLen, nodeIndex === tree.root);
                    }

                    if (!node.isLeaf) {
                        traverse(node.left);
                        traverse(node.right);
                    }
                };

                traverse(tree.root);
            }

            drawLeafNode(x, y, key, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x - 30);
                rect.setAttribute('y', y - 15);
                rect.setAttribute('width', 60);
                rect.setAttribute('height', 30);
                rect.setAttribute('rx', 4);
                rect.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-leaf');
                g.appendChild(rect);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `$${key}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }

            drawInternalNode(x, y, prefixLen, isRoot) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'tree-node-svg');

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 20);
                circle.setAttribute('class', isRoot ? 'tree-node-root' : 'tree-node-internal');
                g.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 5);
                text.setAttribute('class', 'tree-label');
                text.textContent = `b${prefixLen}`;
                g.appendChild(text);

                this.svg.appendChild(g);
            }
        }

        // ================= Hierarchical View =================
        class HierarchicalView {
            constructor(container) {
                this.container = container;
            }

            renderTree(critbitTree) {
                this.container.innerHTML = '';

                if (critbitTree.root === EMPTY) {
                    this.container.innerHTML = '<div class="empty-state">Tree visualization will appear here</div>';
                    return;
                }

                const html = this.renderNode(critbitTree, critbitTree.root, true);
                this.container.innerHTML = html;
            }

            renderNode(tree, nodeIndex, isRoot = false) {
                if (nodeIndex === EMPTY) return '';

                const node = tree.nodes[nodeIndex];
                const nodeClass = isRoot ? 'root' : (node.isLeaf ? 'leaf' : 'internal');

                let html = `<div class="tree-node-hier ${nodeClass}">`;

                if (node.isLeaf) {
                    html += `<div class="node-label">Leaf: $${node.key}</div>`;
                    html += `<div class="node-details">Order: #${node.orderIndex}</div>`;
                } else {
                    html += `<div class="node-label">Internal: bit ${node.prefixLen}</div>`;
                    html += `<div class="tree-children">`;
                    if (node.left !== EMPTY) {
                        html += this.renderNode(tree, node.left);
                    }
                    if (node.right !== EMPTY) {
                        html += this.renderNode(tree, node.right);
                    }
                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            }
        }

        // ================= Global State =================
        let orderBook = {
            orders: [],
            last_order_id: 0
        };

        let critbitTree = new CritBitTree(100);
        let graphVisualizer = new CritBitGraphVisualizer(document.getElementById('critbitSVG'));
        let hierarchyView = new HierarchicalView(document.getElementById('treeHierarchy'));

        let totalMatches = 0;
        let totalVolume = 0;

        // ================= Logging =================
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // ================= UI Updates =================
        function updateStats() {
            document.getElementById('statOrders').textContent = orderBook.orders.length;
            document.getElementById('statMatches').textContent = totalMatches;
            document.getElementById('statVolume').textContent = totalVolume;
        }

        function renderOrderBook() {
            const container = document.getElementById('orderBook');

            if (orderBook.orders.length === 0) {
                container.innerHTML = '<div class="empty-state">No orders in the book<br><small>Connect wallet and place orders to see them here</small></div>';
                return;
            }

            const sortedOrders = [...orderBook.orders].sort((a, b) => {
                const priceCmp = a.price - b.price;
                if (priceCmp !== 0) return priceCmp;
                return a.created_at - b.created_at;
            });

            container.innerHTML = sortedOrders.map(order => {
                const ownerDisplay = order.owner 
                    ? `${order.owner.slice(0, 4)}...${order.owner.slice(-4)}`
                    : (order.trader || 'Unknown');
                
                const explorerLink = order.tx_signature 
                    ? `<a href="https://explorer.solana.com/tx/${order.tx_signature}?cluster=devnet" target="_blank" style="color: #00aaff; text-decoration: none;">View TX</a>`
                    : '';

                return `
                    <div class="order-item ${order.side}">
                        <div class="order-meta">
                            <span><strong>#${order.order_id}</strong></span>
                            <span class="order-price ${order.side}">$${order.price}</span>
                            <button onclick="cancelOrder(${order.order_id})" class="btn-cancel">Cancel</button>
                        </div>
                        <div class="order-details">
                            ${order.side.toUpperCase()}: ${ownerDisplay} | ${order.amount} tokens
                            ${order.order_type ? `| ${order.order_type}` : ''}
                            ${explorerLink ? `<br>${explorerLink}` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateVisualization() {
            graphVisualizer.renderTree(critbitTree);
            hierarchyView.renderTree(critbitTree);
        }

        // ================= Order Placement =================
        // Wait for ZK2P module to be ready
        async function waitForZK2P(maxAttempts = 50) {
            for (let i = 0; i < maxAttempts; i++) {
                if (window.ZK2P && window.ZK2P.getOrCreateTokenAccount && window.ZK2P.createPlaceOrderTransaction) {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return false;
        }
        
        async function placeAskOrder() {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1554',message:'placeAskOrder ENTRY',data:{hasPhantomWallet:!!phantomWallet,hasConnectedPubkey:!!connectedPubkey,hasZK2P:!!window.ZK2P,hasGetOrCreateTokenAccount:!!(window.ZK2P && window.ZK2P.getOrCreateTokenAccount)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H2'})}).catch(()=>{});
            // #endregion
            
            if (!phantomWallet || !connectedPubkey) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1556',message:'placeAskOrder - wallet not connected',data:{phantomWallet:!!phantomWallet,connectedPubkey:!!connectedPubkey},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H2'})}).catch(()=>{});
                // #endregion
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            // Wait for ZK2P module to be ready
            const zk2pReady = await waitForZK2P();
            if (!zk2pReady) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1561',message:'placeAskOrder - ZK2P not available after wait',data:{hasZK2P:!!window.ZK2P,hasGetOrCreateTokenAccount:!!(window.ZK2P && window.ZK2P.getOrCreateTokenAccount)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H2'})}).catch(()=>{});
                // #endregion
                log('[Error] ZK2P module not loaded. Please refresh the page.', 'error');
                return;
            }

            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);
            const paymentMethod = document.getElementById('payment').value || 'PayPal';
            const tokenMintStr = document.getElementById('tokenMint').value.trim();

            if (!amount || !price) {
                log('[Error] Amount and price are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            if (!tokenMintStr) {
                log('[Error] Token mint address is required', 'error');
                return;
            }

            const orderType = document.getElementById('order-type').value || 'limit';
            
            log(`[Order] Placing ASK: ${amount} @ $${price}...`, 'info');

            try {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1592',message:'placeAskOrder - building transaction',data:{tokenMint:tokenMintStr,hasAppConfig:!!appConfig,programId:appConfig?.programId || 'default',amount,price,orderType},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H5'})}).catch(()=>{});
                // #endregion
                
                // Build and send on-chain transaction
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig?.programId || 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB');
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);
                
                // Get user's token account (ATA)
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1598',message:'Calling getOrCreateTokenAccount',data:{wallet:wallet.toString(),tokenMint:tokenMint.toString()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H5'})}).catch(()=>{});
                // #endregion
                
                const userTokenAccount = await window.ZK2P.getOrCreateTokenAccount(connection, wallet, tokenMint);
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1602',message:'Creating place order transaction',data:{side:'ask',price,quantity:amount,orderTypeValue:orderType === 'fok' ? 4 : 0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H5'})}).catch(()=>{});
                // #endregion
                
                const orderTypeValue = orderType === 'fok' ? 4 : 0; // 0 = Limit, 4 = FOK
                
                const transaction = await window.ZK2P.createPlaceOrderTransaction({
                    connection,
                    programId,
                    wallet,
                    tokenMint,
                    userTokenAccount,
                    side: 'ask',
                    price,
                    quantity: amount,
                    orderType: orderTypeValue,
                    paymentMethod
                });

                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1616',message:'Signing and sending transaction via Phantom',data:{hasTransaction:!!transaction,hasPhantomWallet:!!phantomWallet},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H5'})}).catch(()=>{});
                // #endregion

                // Sign and send via Phantom
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log(`[Transaction] Sent! Confirming...`, 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log(`[Success] ASK order placed on-chain!`, 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');
                
                // Refresh order book after short delay
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);
                
            } catch (error) {
                log(`[Error] Failed to place order: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function placeBidOrder() {
            if (!phantomWallet || !connectedPubkey) {
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            // Wait for ZK2P module to be ready
            const zk2pReady = await waitForZK2P();
            if (!zk2pReady) {
                log('[Error] ZK2P module not loaded. Please refresh the page.', 'error');
                return;
            }

            const trader = document.getElementById('trader').value.trim();
            const amount = parseInt(document.getElementById('amount').value);
            const price = parseInt(document.getElementById('price').value);
            const paymentMethod = document.getElementById('payment').value || 'PayPal';
            const tokenMintStr = document.getElementById('tokenMint').value.trim();

            if (!amount || !price) {
                log('[Error] Amount and price are required', 'error');
                return;
            }

            if (amount <= 0 || price <= 0) {
                log('[Error] Amount and price must be positive', 'error');
                return;
            }

            if (!tokenMintStr) {
                log('[Error] Token mint address is required', 'error');
                return;
            }

            const orderType = document.getElementById('order-type').value || 'limit';
            
            log(`[Order] Placing BID: ${amount} @ $${price}...`, 'info');

            try {
                // Build and send on-chain transaction
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig?.programId || 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB');
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);
                
                // Get user's token account (ATA)
                const userTokenAccount = await window.ZK2P.getOrCreateTokenAccount(connection, wallet, tokenMint);
                
                const orderTypeValue = orderType === 'fok' ? 4 : 0; // 0 = Limit, 4 = FOK
                
                const transaction = await window.ZK2P.createPlaceOrderTransaction({
                    connection,
                    programId,
                    wallet,
                    tokenMint,
                    userTokenAccount,
                    side: 'bid',
                    price,
                    quantity: amount,
                    orderType: orderTypeValue,
                    paymentMethod
                });

                // Sign and send via Phantom
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log(`[Transaction] Sent! Confirming...`, 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log(`[Success] BID order placed on-chain!`, 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');
                
                // Refresh order book after short delay
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);
                
            } catch (error) {
                log(`[Error] Failed to place order: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function executeLimitBid(trader, amount, price, matchingAsks) {
            // 1:1 MATCHING - Only match against FIRST compatible ask
            if (matchingAsks.length === 0) {
                log('[Limit] No matching orders found', 'error');
                return;
            }

            // Match against FIRST ask only (1:1 buyer:seller)
            const askOrder = matchingAsks[0];
            const fillAmount = Math.min(amount, askOrder.amount);
            
            log(`[Match] 1:1 - ${fillAmount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += fillAmount;

            // Update ask order
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                orderBook.orders[orderIndex].amount -= fillAmount;
                if (orderBook.orders[orderIndex].amount <= 0) {
                    critbitTree.remove(askOrder.price);
                    orderBook.orders.splice(orderIndex, 1);
                    log(`[CritBit] Removed ask order #${askOrder.order_id}`, 'info');
                }
            }

            const remaining = amount - fillAmount;
            log(`[Limit] Matched ${fillAmount}/${amount} tokens (1:1 single seller)`, 'success');
            
            // Show payment section for P2P settlement
            if (window.ZK2P && window.ZK2P.showPaymentSection) {
                // Determine if current user is buyer (placing bid) or seller (had ask order)
                const isBuyer = true; // User placing bid is the buyer
                window.ZK2P.showPaymentSection(isBuyer, askOrder.order_id);
            }

            // If remaining, add as resting limit order
            if (remaining > 0) {
                orderBook.last_order_id++;
                const restingBid = {
                    trader,
                    amount: remaining,
                    price,
                    side: 'bid',
                    order_type: 'limit',
                    created_at: Date.now(),
                    order_id: orderBook.last_order_id
                };
                orderBook.orders.push(restingBid);
                critbitTree.insert(price, orderBook.last_order_id);
                log(`[Limit] Resting bid added: ${remaining} @ $${price}`, 'info');
            }
        }

        function executeFOKBid(trader, amount, price, matchingAsks, totalAvailable) {
            // FOK: Must match EXACTLY with single ask (1:1 + exact amount)
            if (matchingAsks.length === 0) {
                log('[FOK] No matching orders - REJECTED', 'error');
                return;
            }

            // Check if FIRST ask can fill the EXACT amount
            const askOrder = matchingAsks[0];
            
            if (askOrder.amount !== amount) {
                log('[FOK] Cannot fill exactly - REJECTED', 'error');
                log(`[FOK] Need exactly ${amount}, but first ask has ${askOrder.amount}`, 'error');
                return;
            }

            // Perfect match - fill completely
            log(`[Match] 1:1 FOK - ${amount} tokens @ $${askOrder.price} from ${askOrder.trader}`, 'warning');
            
            totalMatches++;
            totalVolume += amount;

            // Remove ask order completely
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === askOrder.order_id);
            if (orderIndex !== -1) {
                critbitTree.remove(askOrder.price);
                orderBook.orders.splice(orderIndex, 1);
            }

            log(`[FOK] Filled ${amount}/${amount} tokens exactly (1:1 perfect match)`, 'success');
        }

        function cancelOrder(orderId) {
            const orderIndex = orderBook.orders.findIndex(o => o.order_id === orderId);
            if (orderIndex === -1) {
                log(`[Error] Order #${orderId} not found`, 'error');
                return;
            }
            
            const order = orderBook.orders[orderIndex];
            
            // Remove from CritBit tree if this was the last order at this price
            const ordersAtPrice = orderBook.orders.filter(o => o.price === order.price && o.order_id !== orderId);
            if (ordersAtPrice.length === 0) {
                try {
                    critbitTree.remove(order.price);
                    log(`[CritBit] Removed price level ${order.price} from tree`, 'info');
                } catch (e) {
                    log(`[CritBit] ${e.message}`, 'warning');
                }
            }
            
            // Remove from order book
            orderBook.orders.splice(orderIndex, 1);
            
            log(`[Cancel] Order #${orderId} cancelled: ${order.trader}, ${order.amount} @ $${order.price}`, 'warning');
            
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        function clearAll() {
            orderBook.orders = [];
            orderBook.last_order_id = 0;
            totalMatches = 0;
            totalVolume = 0;
            critbitTree = new CritBitTree(100);
            log('[System] All orders cleared', 'warning');
            renderOrderBook();
            updateVisualization();
            updateStats();
        }

        // ================= Match Orders On-Chain =================
        async function matchOrdersOnChain() {
            if (!phantomWallet || !connectedPubkey) {
                log('[Error] Please connect Phantom wallet first', 'error');
                return;
            }

            if (!appConfig) {
                log('[Error] Config not loaded', 'error');
                return;
            }

            const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
            const amount = parseInt(document.getElementById('amount').value) || 100;
            const price = parseInt(document.getElementById('price').value) || 50;
            const orderType = document.getElementById('order-type')?.value || 'limit';

            log('[Match] Attempting to match orders on-chain...', 'info');

            try {
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);
                const wallet = new solanaWeb3.PublicKey(connectedPubkey);

                // Derive OrderBook PDA
                const [orderBook] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('order_book'), tokenMint.toBuffer()],
                    programId
                );

                // Build match_order instruction using discriminator from onchain-transactions.js
                // Instruction data: discriminator (8 bytes) + side (1 byte) + quantity (8 bytes) + limit_price (8 bytes) + order_type (1 byte)
                const instructionData = Buffer.alloc(26);
                
                // Use MATCH_ORDER discriminator from window.ZK2P.INSTRUCTIONS if available
                let matchDiscriminator;
                if (window.ZK2P && window.ZK2P.INSTRUCTIONS && window.ZK2P.INSTRUCTIONS.MATCH_ORDER) {
                    matchDiscriminator = window.ZK2P.INSTRUCTIONS.MATCH_ORDER;
                } else {
                    // Fallback discriminator
                    matchDiscriminator = Buffer.from([0x65, 0x4c, 0x8a, 0x9f, 0x23, 0x7d, 0x1e, 0xb2]);
                }
                
                matchDiscriminator.copy(instructionData, 0);
                instructionData.writeUInt8(0, 8); // Side: 0 = Bid (buyer matching against asks)
                instructionData.writeBigUInt64LE(BigInt(amount), 9); // Quantity
                instructionData.writeBigUInt64LE(BigInt(price), 17); // Limit price
                
                // Order type: 0 = Limit, 4 = FOK
                const orderTypeValue = orderType === 'fok' ? 4 : 0;
                instructionData.writeUInt8(orderTypeValue, 25);

                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: wallet, isSigner: true, isWritable: true }, // owner (matcher)
                        { pubkey: orderBook, isSigner: false, isWritable: true }, // order_book
                        { pubkey: tokenMint, isSigner: false, isWritable: false }, // token_mint
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false }, // system_program
                    ],
                    programId,
                    data: instructionData
                });

                const transaction = new solanaWeb3.Transaction().add(instruction);
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = wallet;

                // Sign and send
                const { signature } = await phantomWallet.signAndSendTransaction(transaction);
                
                log('[Transaction] Match sent! Confirming...', 'info');
                await connection.confirmTransaction(signature, 'confirmed');
                
                log('[Success] Orders matched on-chain!', 'success');
                log(`[Explorer] https://explorer.solana.com/tx/${signature}?cluster=devnet`, 'info');

                // Determine buyer/seller role
                // If connected wallet matches buyer address, they are buyer; otherwise seller
                const isBuyer = connectedPubkey === appConfig.buyerAddress || 
                                connectedPubkey !== appConfig.sellerAddress;
                
                // Generate order_id for payment tracking (use timestamp as order_id)
                const matchedOrderId = Date.now();
                
                // Store matched order details globally
                window.currentMatchedOrder = {
                    order_id: matchedOrderId,
                    side: isBuyer ? 'bid' : 'ask',
                    amount: amount,
                    price: price,
                    counterparty: isBuyer ? appConfig.sellerAddress : appConfig.buyerAddress,
                    tx_signature: signature
                };

                // Create matched order in OrderStore (Pending state)
                if (appConfig.orderStoreProgramId && window.ZK2P && window.ZK2P.createMatchedOrderTransaction) {
                    try {
                        const orderStoreProgramId = new solanaWeb3.PublicKey(appConfig.orderStoreProgramId);
                        const { transaction: createOrderTx, matchedOrder } = await window.ZK2P.createMatchedOrderTransaction({
                            connection,
                            orderStoreProgramId,
                            wallet,
                            orderId: matchedOrderId,
                            bidder: isBuyer ? connectedPubkey : appConfig.buyerAddress,
                            seller: isBuyer ? appConfig.sellerAddress : connectedPubkey,
                            tokenMint,
                            amount,
                            price
                        });
                        
                        const createOrderSignature = await phantomWallet.signAndSendTransaction(createOrderTx);
                        await connection.confirmTransaction(createOrderSignature, 'confirmed');
                        
                        log('[OrderStore] Matched order created (Pending state)', 'success');
                        log(`[OrderStore PDA] ${matchedOrder.toString()}`, 'info');
                        log(`[Explorer] https://explorer.solana.com/tx/${createOrderSignature}?cluster=devnet`, 'info');
                    } catch (orderStoreError) {
                        log(`[OrderStore] Warning: Could not create matched order: ${orderStoreError.message}`, 'warning');
                        console.warn('OrderStore create error:', orderStoreError);
                    }
                }

                // If ZK Fiat Mode enabled, show payment section
                if (window.zkFiatModeEnabled && window.ZK2P && window.ZK2P.showPaymentSection) {
                    window.ZK2P.showPaymentSection(isBuyer, matchedOrderId);
                } else if (!window.zkFiatModeEnabled) {
                    log('[Match] ZK Fiat Mode disabled - Trade settled immediately', 'info');
                }

                // Refresh order book
                setTimeout(() => window.fetchOrderBookState && window.fetchOrderBookState(), 2000);

            } catch (error) {
                log(`[Error] Match failed: ${error.message}`, 'error');
                console.error(error);
            }
        }

        // ================= Fetch On-Chain OrderBook State =================
        window.fetchOrderBookState = async function() {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1981',message:'fetchOrderBookState ENTRY',data:{hasAppConfig:!!appConfig,hasDefaultTokenMint:!!(appConfig && appConfig.defaultTokenMint)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H3'})}).catch(()=>{});
            // #endregion
            
            if (!appConfig || !appConfig.defaultTokenMint) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1983',message:'Config check FAILED',data:{appConfig:appConfig ? 'exists' : 'null',hasDefaultTokenMint:!!(appConfig && appConfig.defaultTokenMint)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H3'})}).catch(()=>{});
                // #endregion
                log('[OrderBook] Config not loaded yet', 'warning');
                return;
            }

            // Ensure Buffer is available
            // #region agent log
            const bufferCheck = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
            fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1988',message:'Buffer availability check',data:{bufferAvailable:bufferCheck,typeofBuffer:typeof Buffer,hasBufferFrom:typeof Buffer !== 'undefined' ? typeof Buffer.from : 'Buffer undefined',windowBuffer:typeof window !== 'undefined' ? typeof window.Buffer : 'window undefined'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
            // #endregion
            
            if (typeof Buffer === 'undefined' || typeof Buffer.from !== 'function') {
                log('[OrderBook] Buffer not available - waiting...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check Buffer in multiple locations
                const BufferRef = (typeof window !== 'undefined' && window.Buffer) || Buffer || (typeof global !== 'undefined' && global.Buffer);
                if (!BufferRef || typeof BufferRef.from !== 'function') {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1995',message:'Buffer still not available after wait',data:{BufferRef:BufferRef ? 'exists' : 'null',hasBufferRefFrom:BufferRef ? typeof BufferRef.from : 'BufferRef null'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                    log('[OrderBook] Buffer still not available - please refresh page', 'error');
                    console.error('[OrderBook] Debug - window.Buffer:', typeof window !== 'undefined' ? typeof window.Buffer : 'window undefined');
                    console.error('[OrderBook] Debug - Buffer:', typeof Buffer);
                    return;
                }
            }

            try {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2002',message:'Starting OrderBook fetch - BEFORE PDA derivation',data:{tokenMint:appConfig.defaultTokenMint,programId:appConfig.programId,hasConnection:!!connection,hasSolanaWeb3:typeof solanaWeb3 !== 'undefined'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
                // #endregion
                
                const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);

                // Derive OrderBook PDA
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2008',message:'Deriving OrderBook PDA',data:{tokenMint:tokenMint.toString(),programId:programId.toString(),bufferAvailable:typeof Buffer !== 'undefined' && typeof Buffer.from === 'function'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
                // #endregion
                
                const [orderBookPda] = await solanaWeb3.PublicKey.findProgramAddress(
                    [Buffer.from('order_book'), tokenMint.toBuffer()],
                    programId
                );

                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2014',message:'Fetching account info from chain',data:{orderBookPda:orderBookPda.toString()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
                // #endregion

                // Fetch account data
                const accountInfo = await connection.getAccountInfo(orderBookPda);
                if (!accountInfo) {
                    log('[OrderBook] Account not found - needs initialization', 'warning');
                    orderBook.orders = [];
                    renderOrderBook();
                    return;
                }

                log('[OrderBook] Fetched on-chain data successfully', 'success');

                // Load IDL and deserialize using Anchor
                try {
                    const idlResponse = await fetch('market.json');
                    const idl = await idlResponse.json();
                    
                    // Ensure Anchor is available (try multiple possible global names)
                    // #region agent log
                    const anchorCheck = {windowAnchor:typeof window !== 'undefined' ? typeof window.anchor : 'window undefined',windowAnchorCap:typeof window !== 'undefined' ? typeof window.Anchor : 'window undefined',anchorVar:typeof anchor};
                    fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2030',message:'Checking Anchor library availability',data:anchorCheck,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H4'})}).catch(()=>{});
                    // #endregion
                    
                    const Anchor = window.anchor || window.Anchor || anchor;
                    if (!Anchor) {
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2032',message:'Anchor library NOT available',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H4'})}).catch(()=>{});
                        // #endregion
                        throw new Error('Anchor library not loaded');
                    }
                    
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2036',message:'Creating Anchor program instance',data:{hasIdl:!!idl,programId:programId.toString()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H4'})}).catch(()=>{});
                    // #endregion
                    
                    // Create Anchor program instance
                    const program = new Anchor.Program(idl, programId, {
                        connection: connection
                    });
                    
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2042',message:'Deserializing OrderBook account',data:{accountDataLength:accountInfo.data.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H4'})}).catch(()=>{});
                    // #endregion
                    
                    // Deserialize OrderBook account (Anchor handles discriminator automatically)
                    // Account data starts with 8-byte discriminator, which Anchor's decoder handles
                    const orderBookAccount = program.account.orderBook.coder.accounts.decode(
                        'OrderBook',
                        accountInfo.data
                    );
                    
                    // Log deserialized data structure
                    console.log('[OrderBook] Deserialized account:', orderBookAccount);
                    
                    // Extract property names (Anchor converts snake_case to camelCase)
                    const totalOrders = orderBookAccount.totalOrders || orderBookAccount.total_orders || 0;
                    const bestBid = orderBookAccount.bestBid || orderBookAccount.best_bid || 0;
                    const bestAsk = orderBookAccount.bestAsk || orderBookAccount.best_ask || 0;
                    const orderQueues = orderBookAccount.orderQueues || orderBookAccount.order_queues || [];
                    const bidsTree = orderBookAccount.bids || {};
                    const asksTree = orderBookAccount.asks || {};
                    
                    log(`[OrderBook] Deserialized - Total orders: ${totalOrders}`, 'info');
                    log(`[OrderBook] Best bid: ${bestBid}, Best ask: ${bestAsk}`, 'info');
                    log(`[OrderBook] Order queues: ${orderQueues.length}`, 'info');
                    log(`[OrderBook] Bids tree nodes: ${bidsTree.nodes ? bidsTree.nodes.length : 0}`, 'info');
                    log(`[OrderBook] Asks tree nodes: ${asksTree.nodes ? asksTree.nodes.length : 0}`, 'info');
                    
                    // Helper to traverse CritBit tree and collect order queue indices
                    function collectQueueIndices(tree, side) {
                        const indices = new Set();
                        if (tree && tree.nodes && Array.isArray(tree.nodes)) {
                            for (const node of tree.nodes) {
                                if (node && node.isLeaf && node.orderIndex !== undefined) {
                                    const queueIdx = Number(node.orderIndex || node.order_index || 0);
                                    if (queueIdx < orderQueues.length) {
                                        indices.add(queueIdx);
                                        console.log(`[OrderBook] ${side} tree: Found leaf at price ${node.key}, queue index ${queueIdx}`);
                                    }
                                }
                            }
                        }
                        return Array.from(indices);
                    }
                    
                    // Get queue indices from CritBit trees
                    const bidQueueIndices = collectQueueIndices(bidsTree, 'BID');
                    const askQueueIndices = collectQueueIndices(asksTree, 'ASK');
                    const allQueueIndices = [...new Set([...bidQueueIndices, ...askQueueIndices])];
                    
                    log(`[OrderBook] Found ${allQueueIndices.length} active price levels (${bidQueueIndices.length} bids, ${askQueueIndices.length} asks)`, 'info');
                    
                    // Extract all orders from order_queues
                    // Only process queues that are referenced by CritBit trees
                    const allOrders = [];
                    console.log('[OrderBook] Raw orderQueues:', orderQueues);
                    console.log('[OrderBook] Active queue indices:', allQueueIndices);
                    
                    if (Array.isArray(orderQueues)) {
                        // Process all queues, or only active ones if we found them
                        const queuesToProcess = allQueueIndices.length > 0 ? allQueueIndices : Array.from({length: orderQueues.length}, (_, i) => i);
                        log(`[OrderBook] Processing ${queuesToProcess.length} order queues`, 'info');
                        
                        for (const queueIdx of queuesToProcess) {
                            if (queueIdx >= orderQueues.length) continue;
                            
                            const queue = orderQueues[queueIdx];
                            console.log(`[OrderBook] Queue ${queueIdx}:`, queue);
                            
                            // Handle different possible structures
                            const orders = queue.orders || queue.order || [];
                            if (Array.isArray(orders) && orders.length > 0) {
                                log(`[OrderBook] Queue ${queueIdx} has ${orders.length} orders`, 'info');
                                for (const order of orders) {
                                    // Convert Anchor types to UI format
                                    // Handle both camelCase and snake_case property names
                                    const orderId = order.orderId || order.order_id;
                                    const owner = order.owner;
                                    const quantity = order.quantity || 0;
                                    const price = order.price || 0;
                                    const side = order.side;
                                    const orderType = order.orderType || order.order_type;
                                    const timestamp = order.timestamp || 0;
                                    const paymentStatus = order.paymentStatus || order.payment_status;
                                    
                                    // Parse side enum
                                    let sideStr = 'unknown';
                                    if (side) {
                                        if (side.bid !== undefined || side === 'Bid' || side === 0) {
                                            sideStr = 'bid';
                                        } else if (side.ask !== undefined || side === 'Ask' || side === 1) {
                                            sideStr = 'ask';
                                        }
                                    }
                                    
                                    // Parse order type enum
                                    let orderTypeStr = 'limit';
                                    if (orderType) {
                                        if (orderType.limit !== undefined || orderType === 'Limit' || orderType === 0) {
                                            orderTypeStr = 'limit';
                                        } else if (orderType.fillOrKill !== undefined || orderType === 'FillOrKill' || orderType === 4) {
                                            orderTypeStr = 'fok';
                                        }
                                    }
                                    
                                    // Parse payment status
                                    let paymentStatusStr = 'Pending';
                                    if (paymentStatus) {
                                        if (paymentStatus.pending !== undefined || paymentStatus === 'Pending' || paymentStatus === 0) {
                                            paymentStatusStr = 'Pending';
                                        } else if (paymentStatus.paymentMarked !== undefined || paymentStatus === 'PaymentMarked' || paymentStatus === 1) {
                                            paymentStatusStr = 'PaymentMarked';
                                        } else if (paymentStatus.verified !== undefined || paymentStatus === 'Verified' || paymentStatus === 3) {
                                            paymentStatusStr = 'Verified';
                                        }
                                    }
                                    
                                    const uiOrder = {
                                        order_id: orderId ? orderId.toString() : '0',
                                        owner: owner ? owner.toString() : '',
                                        amount: Number(quantity) || 0,
                                        price: Number(price) || 0,
                                        side: sideStr,
                                        order_type: orderTypeStr,
                                        timestamp: Number(timestamp) || 0,
                                        payment_status: paymentStatusStr,
                                        created_at: Number(timestamp) * 1000 || Date.now(),
                                        trader: owner ? `${owner.toString().slice(0, 4)}...${owner.toString().slice(-4)}` : 'Unknown'
                                    };
                                    
                                    // Only add if we have valid data
                                    if (uiOrder.price > 0 && uiOrder.amount > 0) {
                                        allOrders.push(uiOrder);
                                        console.log('[OrderBook] Added order:', uiOrder);
                                    } else {
                                        console.warn('[OrderBook] Skipping invalid order:', uiOrder);
                                    }
                                }
                            } else {
                                console.warn(`[OrderBook] Queue ${i} orders is not an array:`, orders);
                            }
                        }
                    } else {
                        log('[OrderBook] orderQueues is not an array, trying alternative extraction', 'warning');
                        console.log('[OrderBook] Attempting to extract from CritBit trees directly...');
                        
                        // Try to extract from bids and asks trees if available
                        const bidsTree = orderBookAccount.bids || orderBookAccount.bidsTree;
                        const asksTree = orderBookAccount.asks || orderBookAccount.asksTree;
                        
                        if (bidsTree && bidsTree.nodes) {
                            log(`[OrderBook] Found bids tree with ${bidsTree.nodes.length} nodes`, 'info');
                        }
                        if (asksTree && asksTree.nodes) {
                            log(`[OrderBook] Found asks tree with ${asksTree.nodes.length} nodes`, 'info');
                        }
                    }
                    
                    // Update local order book state
                    orderBook.orders = allOrders;
                    
                    if (allOrders.length > 0) {
                        log(`[OrderBook] Extracted ${allOrders.length} orders from on-chain data`, 'success');
                        console.log('[OrderBook] Orders to display:', allOrders);
                    } else {
                        log(`[OrderBook] No orders found in order_queues. Total orders reported: ${totalOrders}`, 'warning');
                        log(`[OrderBook] Best bid: ${bestBid}, Best ask: ${bestAsk}`, 'info');
                        console.log('[OrderBook] Full account data:', orderBookAccount);
                    }
                    
                    // Update UI
                    renderOrderBook();
                    updateStats();
                    
                    // Log what's in the orderBook state
                    console.log('[OrderBook] Final orderBook.orders:', orderBook.orders);
                    console.log('[OrderBook] orderBook.orders.length:', orderBook.orders.length);
                    
                } catch (deserializeError) {
                    log(`[OrderBook] Deserialization error: ${deserializeError.message}`, 'error');
                    console.error('Deserialization error:', deserializeError);
                    console.error('Error stack:', deserializeError.stack);
                    // Fallback: just show that we fetched the data
                    renderOrderBook();
                }
                
            } catch (error) {
                log(`[OrderBook] Error fetching: ${error.message}`, 'error');
                console.error(error);
            }
        };

        // Initialize
        updateStats();
        window.addEventListener('resize', () => updateVisualization());

        // Auto-refresh OrderBook every 5 seconds if wallet connected
        setInterval(async () => {
            if (phantomWallet && connectedPubkey && appConfig) {
                await window.fetchOrderBookState();
            }
        }, 5000);
    </script>

    <!-- Solana Web3.js and Wallet Adapter -->
    <!-- Load dynamically after Buffer is confirmed ready -->
    <script>
        (function() {
            'use strict';
            
            let solanaWeb3Loaded = false;
            let anchorLoaded = false;
            
            function checkBufferAndLoad() {
                // Verify Buffer is available
                if (typeof Buffer === 'undefined' || typeof Buffer.from !== 'function') {
                    console.warn('[Init] Buffer not available yet, will retry...');
                    return false;
                }
                
                console.log('[Init] Buffer confirmed ready, loading Solana libraries...');
                return true;
            }
            
            function showBufferError() {
                // Only show error if buffer-error div doesn't already exist
                if (document.getElementById('buffer-error')) {
                    return;
                }
                
                // Show user-friendly error message
                const errorDiv = document.createElement('div');
                errorDiv.id = 'buffer-error';
                errorDiv.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: #ff4444; color: white; padding: 15px; text-align: center; z-index: 10000; font-family: sans-serif;';
                errorDiv.innerHTML = '<strong>Error:</strong> Buffer polyfill failed to load. Please refresh the page. If the problem persists, check your internet connection.';
                document.body.appendChild(errorDiv);
            }
            
            function loadSolanaWeb3() {
                if (solanaWeb3Loaded) return;
                
                // Check Buffer without showing error (errors shown only after retries)
                if (typeof Buffer === 'undefined' || typeof Buffer.from !== 'function') {
                    console.warn('[Init] Buffer not ready yet, will retry...');
                    return;
                }
                
                console.log('[Init] Buffer confirmed ready, loading Solana libraries...');
                
                console.log('[Init] Loading @solana/web3.js...');
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js';
                script.onload = function() {
                    if (typeof window.solanaWeb3 !== 'undefined') {
                        solanaWeb3Loaded = true;
                        console.log('[Init] @solana/web3.js loaded successfully');
                        window.dispatchEvent(new Event('solanaWeb3Ready'));
                        loadAnchor();
                    } else {
                        console.error('[Init] @solana/web3.js loaded but solanaWeb3 not found on window');
                        showSolanaError();
                    }
                };
                script.onerror = function() {
                    console.error('[Init] Failed to load @solana/web3.js');
                    showSolanaError();
                };
                document.head.appendChild(script);
            }
            
            function loadAnchor() {
                if (anchorLoaded) return;
                
                console.log('[Init] Loading @coral-xyz/anchor...');
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/@coral-xyz/anchor@0.29.0/dist/browser/index.js';
                script.onload = function() {
                    anchorLoaded = true;
                    console.log('[Init] @coral-xyz/anchor loaded successfully');
                    window.dispatchEvent(new Event('anchorReady'));
                };
                script.onerror = function() {
                    console.error('[Init] Failed to load @coral-xyz/anchor');
                };
                document.head.appendChild(script);
            }
            
            function showSolanaError() {
                const errorDiv = document.createElement('div');
                errorDiv.id = 'solana-error';
                errorDiv.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: #ff4444; color: white; padding: 15px; text-align: center; z-index: 10000; font-family: sans-serif;';
                errorDiv.innerHTML = '<strong>Error:</strong> Failed to load Solana Web3.js library. Please check your internet connection and refresh the page.';
                document.body.appendChild(errorDiv);
            }
            
            // Wait for Buffer to be ready, then load Solana libraries
            function attemptLoadSolana() {
                if (checkBufferAndLoad()) {
                    loadSolanaWeb3();
                    return true;
                }
                return false;
            }
            
            // Try immediately if Buffer is already available
            if (attemptLoadSolana()) {
                // Successfully started loading
            } else {
                // Wait for bufferReady event
                window.addEventListener('bufferReady', function() {
                    if (!solanaWeb3Loaded) {
                        attemptLoadSolana();
                    }
                }, { once: true });
                
                // Fallback: try loading after delays (give Buffer time to initialize)
                setTimeout(function() {
                    if (!solanaWeb3Loaded) {
                        if (!attemptLoadSolana()) {
                            // Still not ready, try once more after longer delay
                            setTimeout(function() {
                                if (!solanaWeb3Loaded && !attemptLoadSolana()) {
                                    // After multiple attempts, show error only if Buffer truly isn't available
                                    if (typeof Buffer === 'undefined' || typeof Buffer.from !== 'function') {
                                        console.error('[Init] Buffer still not available after waiting');
                                        showBufferError();
                                    }
                                }
                            }, 1000);
                        }
                    }
                }, 300);
            }
        })();
    </script>
    
    <!-- Phantom Wallet Integration -->
    <!-- Wait for Solana Web3.js to load before initializing -->
    <script>
        (function() {
            'use strict';
            
            function initPhantomIntegration() {
                // Verify solanaWeb3 is available
                if (typeof window === 'undefined' || typeof window.solanaWeb3 === 'undefined') {
                    console.error('[Phantom] solanaWeb3 not available yet');
                    return false;
                }
                
                // Solana Web3 Configuration
                const DEVNET_RPC = 'https://api.devnet.solana.com';
                const connection = new solanaWeb3.Connection(DEVNET_RPC, 'confirmed');
                
                // Deployed Program IDs on Devnet
                const PROGRAM_IDS = {
                    market: 'Bk2pKQsXXvjPChX2G8AWgwoefnwRbTSirtHGnG8yUEdB',
                    orderStore: '9eVsFt83o3qkfaKNMZ6wuom2HL6ScB9sF3NikzDnxrNb',
                    orderProcessor: 'Gn8GGrCgmBQs4tRvf2oeWXjgsqHBcYByDhQiAxGdfFqV'
                };
                
                let phantomWallet = null;
                let connectedPubkey = null;
        
        // Detect and connect to Phantom
        async function detectPhantom() {
            const isPhantomInstalled = window.solana && window.solana.isPhantom;
            
            if (!isPhantomInstalled) {
                log('[Wallet] Phantom wallet not detected. Please install from phantom.app', 'error');
                return false;
            }
            
            log('[Wallet] Phantom detected', 'success');
            return true;
        }
        
        let appConfig = null;
        
        async function connectPhantomWallet() {
            try {
                if (!await detectPhantom()) {
                    window.open('https://phantom.app/', '_blank');
                    return;
                }
                
                const resp = await window.solana.connect();
                connectedPubkey = resp.publicKey.toString();
                phantomWallet = window.solana;
                
                log(`[Wallet] Connected: ${connectedPubkey.slice(0, 8)}...${connectedPubkey.slice(-8)}`, 'success');
                
                // Load config using config-loader.js
                try {
                    if (window.ZK2PConfig && window.ZK2PConfig.loadConfig) {
                        appConfig = await window.ZK2PConfig.loadConfig();
                        console.log(`[Config] Loaded config for ${appConfig.network || 'devnet'}`);
                    } else {
                        // Fallback: try to load config.json directly
                        const configResp = await fetch('config.json');
                        appConfig = await configResp.json();
                        console.log('[Config] Loaded fallback config.json');
                    }
                    
                    // Populate token mint input with default if empty
                    const tokenMintInput = document.getElementById('tokenMint');
                    if (tokenMintInput && !tokenMintInput.value) {
                        tokenMintInput.value = appConfig.defaultTokenMint;
                    }
                    
                    log(`[Config] Loaded ${appConfig.network || 'devnet'} config successfully`, 'success');
                } catch (err) {
                    log(`[Config] Warning: Could not load config - ${err.message}`, 'warning');
                    console.error('[Config] Error:', err);
                }
                
                // Update UI with connected wallet
                const walletBtn = document.getElementById('phantomConnectBtn');
                if (walletBtn) {
                    walletBtn.textContent = `Connected: ${connectedPubkey.slice(0, 4)}...${connectedPubkey.slice(-4)}`;
                    walletBtn.style.background = 'linear-gradient(135deg, #00ff88, #00aa55)';
                }
                
                // Update balances display
                await updateBalances();
                
                // Identify wallet role (seller or buyer)
                if (window.ZK2P && window.ZK2P.identifyWalletRole) {
                    await window.ZK2P.identifyWalletRole();
                }
                
                // Check initialization status
                await checkInitialization();
                
                // Fetch order book state after connection
                if (window.fetchOrderBookState) {
                    setTimeout(() => window.fetchOrderBookState(), 1000);
                }
                
                return true;
            } catch (err) {
                log(`[Wallet] Connection failed: ${err.message}`, 'error');
                return false;
            }
        }
        
        // Disconnect wallet
        async function disconnectPhantom() {
            if (phantomWallet) {
                await phantomWallet.disconnect();
                connectedPubkey = null;
                phantomWallet = null;
                log('[Wallet] Disconnected', 'info');
            }
        }
        
        // Update wallet balances (SOL and token)
        async function updateBalances() {
            if (!connectedPubkey) return;
            
            try {
                // Get SOL balance
                const solBalance = await connection.getBalance(new solanaWeb3.PublicKey(connectedPubkey));
                document.getElementById('solBalance').textContent = (solBalance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
                log(`[Wallet] Balance: ${(solBalance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4)} SOL`, 'info');
                
                // Get token balance if ATA exists
                try {
                    if (window.ZK2P && window.ZK2P.getOrCreateTokenAccount) {
                        const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                        if (tokenMintStr) {
                            const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                            const ata = await window.ZK2P.getOrCreateTokenAccount(connection, new solanaWeb3.PublicKey(connectedPubkey), tokenMint);
                            const tokenAccount = await connection.getTokenAccountBalance(ata);
                            document.getElementById('tokenBalance').textContent = tokenAccount.value.uiAmount || 0;
                            log(`[Wallet] Token balance: ${tokenAccount.value.uiAmount || 0}`, 'info');
                        }
                    } else {
                        log('[Wallet] ZK2P module not loaded yet', 'warning');
                    }
                } catch (e) {
                    document.getElementById('tokenBalance').textContent = '0';
                    log('[Wallet] No token balance found (ATA may not exist yet)', 'warning');
                }
                
                // Show balance display
                document.getElementById('walletBalance').style.display = 'block';
            } catch (error) {
                log(`[Wallet] Error fetching balances: ${error.message}`, 'error');
            }
        }
        
        // Setup Fetch Order Book button handler after everything is loaded
        function setupFetchOrderBookButton() {
            const fetchOrderBookBtn = document.getElementById('fetchOrderBookBtn');
            if (!fetchOrderBookBtn) {
                console.warn('[OrderBook] Fetch button not found');
                return;
            }
            
            // Remove any existing click handlers by cloning
            const newBtn = fetchOrderBookBtn.cloneNode(true);
            fetchOrderBookBtn.parentNode.replaceChild(newBtn, fetchOrderBookBtn);
            
            newBtn.addEventListener('click', async function() {
                console.log('[OrderBook] Button clicked');
                
                if (!window.fetchOrderBookState) {
                    log('[OrderBook] Fetch function not available yet. Please wait...', 'error');
                    console.error('[OrderBook] window.fetchOrderBookState is not defined');
                    return;
                }
                
                newBtn.disabled = true;
                const originalText = newBtn.textContent;
                newBtn.textContent = 'Fetching...';
                
                try {
                    log('[OrderBook] Fetching order book from blockchain...', 'info');
                    await window.fetchOrderBookState();
                    log('[OrderBook] Fetch complete!', 'success');
                } catch (error) {
                    log(`[OrderBook] Error: ${error.message}`, 'error');
                    console.error('[OrderBook] Fetch error:', error);
                } finally {
                    newBtn.disabled = false;
                    newBtn.textContent = originalText;
                }
            });
            
            console.log('[OrderBook] Fetch button handler attached successfully');
        }
        
        // Setup button after page loads
        window.addEventListener('load', () => {
            setTimeout(setupFetchOrderBookButton, 1500);
        });
        
        // Also try immediately if already loaded
        if (document.readyState === 'complete') {
            setTimeout(setupFetchOrderBookButton, 500);
        }

        // Check if on-chain accounts are initialized
        async function checkInitialization() {
            // #region agent log
            const initBufferCheck = (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined' && typeof window.Buffer.from === 'function') ||
                                   (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') ||
                                   (typeof global !== 'undefined' && typeof global.Buffer !== 'undefined' && typeof global.Buffer.from === 'function');
            fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2648',message:'checkInitialization ENTRY',data:{bufferAvailable:initBufferCheck,typeofBuffer:typeof Buffer,windowBuffer:typeof window !== 'undefined' ? typeof window.Buffer : 'window undefined',hasZK2P:!!window.ZK2P},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
            // #endregion
            
            try {
                // Ensure Buffer is available (check both window.Buffer and global Buffer)
                const bufferAvailable = (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined' && typeof window.Buffer.from === 'function') ||
                                       (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') ||
                                       (typeof global !== 'undefined' && typeof global.Buffer !== 'undefined' && typeof global.Buffer.from === 'function');
                
                if (!bufferAvailable) {
                    log('[Init] Buffer not available - waiting...', 'warning');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Check again after wait
                    const bufferAvailableAfterWait = (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined' && typeof window.Buffer.from === 'function') ||
                                                    (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') ||
                                                    (typeof global !== 'undefined' && typeof global.Buffer !== 'undefined' && typeof global.Buffer.from === 'function');
                    
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/b49538f5-4df2-40b6-9a49-131497c6fe63',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2659',message:'checkInitialization - Buffer check after wait',data:{bufferAvailable:bufferAvailableAfterWait},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                    
                    if (!bufferAvailableAfterWait) {
                        log('[Init] Buffer still not available - please refresh page', 'error');
                        console.error('[Init] Debug - window.Buffer:', typeof window !== 'undefined' ? typeof window.Buffer : 'window undefined');
                        console.error('[Init] Debug - Buffer:', typeof Buffer);
                        console.error('[Init] Debug - global.Buffer:', typeof global !== 'undefined' ? typeof global.Buffer : 'global undefined');
                        return false;
                    }
                }
                
                // Ensure we're using the correct Buffer reference
                const BufferRef = (typeof window !== 'undefined' && window.Buffer) || Buffer || (typeof global !== 'undefined' && global.Buffer);
                if (!BufferRef || typeof BufferRef.from !== 'function') {
                    log('[Init] Buffer reference invalid', 'error');
                    return false;
                }
                
                const tokenMintStr = document.getElementById('tokenMint')?.value || appConfig.defaultTokenMint;
                if (!tokenMintStr) {
                    log('[Init] No token mint specified', 'warning');
                    return false;
                }
                
                const tokenMint = new solanaWeb3.PublicKey(tokenMintStr);
                const programId = new solanaWeb3.PublicKey(appConfig.programId);
                
                // Ensure Buffer is available for PDA derivation
                const BufferRef = (typeof window !== 'undefined' && window.Buffer) || Buffer || (typeof global !== 'undefined' && global.Buffer);
                if (!BufferRef || typeof BufferRef.from !== 'function') {
                    log('[Init] Buffer not available for PDA derivation', 'error');
                    return false;
                }
                
                // Check Market
                const [market] = await solanaWeb3.PublicKey.findProgramAddress(
                    [BufferRef.from('market'), tokenMint.toBuffer()],
                    programId
                );
                const marketInfo = await connection.getAccountInfo(market);
                if (!marketInfo) {
                    log('[Init] Market not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] Market account ✓', 'success');
                
                // Check OrderBook
                const [orderBook] = await solanaWeb3.PublicKey.findProgramAddress(
                    [BufferRef.from('order_book'), tokenMint.toBuffer()],
                    programId
                );
                const orderBookInfo = await connection.getAccountInfo(orderBook);
                if (!orderBookInfo) {
                    log('[Init] OrderBook not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] OrderBook account ✓', 'success');
                
                // Check EscrowVault
                const [escrowVault] = await solanaWeb3.PublicKey.findProgramAddress(
                    [BufferRef.from('escrow_vault'), tokenMint.toBuffer()],
                    programId
                );
                const vaultInfo = await connection.getAccountInfo(escrowVault);
                if (!vaultInfo) {
                    log('[Init] Escrow vault not initialized - run: npm run p2p:init', 'error');
                    return false;
                }
                log('[Init] Escrow vault ✓', 'success');
                
                log('[Init] All accounts initialized ✓', 'success');
                return true;
            } catch (error) {
                log(`[Init] Error checking initialization: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Initialize Phantom connection on page load
        window.addEventListener('load', async () => {
            await detectPhantom();
            
            // Auto-connect if previously authorized
            if (window.solana && window.solana.isConnected) {
                await connectPhantomWallet();
            }
        });
        
        // Handle account changes
        if (window.solana) {
            window.solana.on('accountChanged', (publicKey) => {
                if (publicKey) {
                    connectedPubkey = publicKey.toString();
                    log(`[Wallet] Account changed to ${connectedPubkey.slice(0, 8)}...`, 'info');
                } else {
                    disconnectPhantom();
                }
            });
        }
        
                console.log('[2k2Peer] Phantom wallet integration ready');
                console.log('[2k2Peer] Market Program ID:', PROGRAM_IDS.market);
                console.log('[2k2Peer] P2P Payment status tracking enabled');
                
                return true;
            }
            
            // Wait for solanaWeb3 to be ready before initializing
            if (typeof window !== 'undefined' && typeof window.solanaWeb3 !== 'undefined') {
                // Already available, initialize immediately
                initPhantomIntegration();
            } else {
                // Wait for solanaWeb3Ready event
                window.addEventListener('solanaWeb3Ready', function() {
                    initPhantomIntegration();
                }, { once: true });
                
                // Fallback: try after a delay
                setTimeout(function() {
                    if (typeof window !== 'undefined' && typeof window.solanaWeb3 !== 'undefined') {
                        initPhantomIntegration();
                    } else {
                        console.error('[Phantom] solanaWeb3 not available after waiting');
                    }
                }, 1000);
            }
        })();
    </script>
    
    <!-- ZK Fiat Mode Toggle Logic -->
    <script>
        // Initialize ZK Fiat Mode state
        window.zkFiatModeEnabled = true;
        
        // Setup toggle switch functionality
        document.addEventListener('DOMContentLoaded', () => {
            const toggleSwitch = document.getElementById('toggleSwitch');
            const toggleCheckbox = document.getElementById('zkFiatModeToggle');
            
            // Set initial state
            if (toggleCheckbox.checked) {
                toggleSwitch.classList.add('active');
            }
            
            // Handle toggle click
            toggleSwitch.addEventListener('click', () => {
                toggleCheckbox.checked = !toggleCheckbox.checked;
                window.zkFiatModeEnabled = toggleCheckbox.checked;
                
                if (toggleCheckbox.checked) {
                    toggleSwitch.classList.add('active');
                    log('[ZK Fiat Mode] Enabled - P2P payment flow active', 'success');
                } else {
                    toggleSwitch.classList.remove('active');
                    log('[ZK Fiat Mode] Disabled - Direct settlement', 'warning');
                }
            });
            
            log('[ZK Fiat Mode] Initialized - Mode: ' + (window.zkFiatModeEnabled ? 'Enabled' : 'Disabled'), 'info');
        });
    </script>
    
    <!-- On-chain Transaction Integration -->
    <!-- Load after Buffer and Solana Web3.js are ready -->
    <script>
        // Wait for both Buffer and Solana Web3.js before loading onchain-transactions.js
        let onchainTransactionsLoading = false;
        let onchainTransactionsTimeout = null;
        
        function loadOnchainTransactions() {
            // Prevent duplicate loads
            if (onchainTransactionsLoading) {
                return;
            }
            
            const bufferReady = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
            const solanaReady = typeof window !== 'undefined' && typeof window.solanaWeb3 !== 'undefined';
            
            if (bufferReady && solanaReady) {
                onchainTransactionsLoading = true;
                if (onchainTransactionsTimeout) {
                    clearTimeout(onchainTransactionsTimeout);
                    onchainTransactionsTimeout = null;
                }
                
                console.log('[Init] Loading onchain-transactions.js (Buffer and Solana Web3.js ready)');
                const script = document.createElement('script');
                script.src = 'onchain-transactions.js';
                script.onload = function() {
                    console.log('[Init] Onchain transactions module loaded successfully');
                };
                script.onerror = function() {
                    console.error('[Init] Failed to load onchain-transactions.js');
                    onchainTransactionsLoading = false; // Allow retry on error
                    
                    // Show error to user
                    const errorMsg = document.createElement('div');
                    errorMsg.style.cssText = 'position: fixed; top: 50px; left: 0; right: 0; background: #ff4444; color: white; padding: 15px; text-align: center; z-index: 10000; font-family: sans-serif;';
                    errorMsg.innerHTML = '<strong>Error:</strong> Failed to load transaction module. Please refresh the page.';
                    document.body.appendChild(errorMsg);
                };
                document.head.appendChild(script);
            } else {
                // Wait for both dependencies
                let bufferHandler = null;
                let solanaHandler = null;
                let dependenciesReady = false;
                
                const checkAndLoad = function() {
                    if (dependenciesReady) return;
                    
                    const bufReady = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
                    const solReady = typeof window !== 'undefined' && typeof window.solanaWeb3 !== 'undefined';
                    
                    if (bufReady && solReady) {
                        dependenciesReady = true;
                        if (bufferHandler) {
                            window.removeEventListener('bufferReady', bufferHandler);
                        }
                        if (solanaHandler) {
                            window.removeEventListener('solanaWeb3Ready', solanaHandler);
                        }
                        if (onchainTransactionsTimeout) {
                            clearTimeout(onchainTransactionsTimeout);
                            onchainTransactionsTimeout = null;
                        }
                        loadOnchainTransactions();
                    }
                };
                
                if (!bufferReady) {
                    bufferHandler = checkAndLoad;
                    window.addEventListener('bufferReady', bufferHandler, { once: true });
                }
                
                if (!solanaReady) {
                    solanaHandler = checkAndLoad;
                    window.addEventListener('solanaWeb3Ready', solanaHandler, { once: true });
                }
                
                // Check immediately in case events already fired
                checkAndLoad();
                
                // Fallback: try after a delay
                if (onchainTransactionsTimeout) {
                    clearTimeout(onchainTransactionsTimeout);
                }
                onchainTransactionsTimeout = setTimeout(function() {
                    if (!onchainTransactionsLoading) {
                        checkAndLoad();
                    }
                }, 2000);
            }
        }
        
        // Start loading process
        loadOnchainTransactions();
    </script>
</body>
</html>
